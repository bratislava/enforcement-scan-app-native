/* tslint:disable */
/* eslint-disable */
/**
 * Bratislava Enforcement scan app backend
 * Enforcement backend for mobile app for lustrating and creating penalties for bad parking and traffic violations
 *
 * The version of the OpenAPI document: 1.0
 * Contact: inovacie@bratislava.sk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base'

/**
 *
 * @export
 * @interface DefaultResponseHealthcheck
 */
export interface DefaultResponseHealthcheck {
  /**
   * is application it running?
   * @type {boolean}
   * @memberof DefaultResponseHealthcheck
   */
  appRunning: boolean
}
/**
 * Exact error name
 * @export
 * @enum {string}
 */

export const ErrorNameEnum = {
  DatabaseError: 'DATABASE_ERROR',
  AzureError: 'AZURE_ERROR',
  MagproxyError: 'MAGPROXY_ERROR',
  MinioError: 'MINIO_ERROR',
  PricingApiError: 'PRICING_API_ERROR',
  EnforcementError: 'ENFORCEMENT_ERROR',
  ParkdotsError: 'PARKDOTS_ERROR',
  MissingUdr: 'MISSING_UDR',
  MissingEnv: 'MISSING_ENV',
  UnexpectedError: 'UNEXPECTED_ERROR',
  NotFound: 'NOT_FOUND',
  ArcgisError: 'ARCGIS_ERROR',
} as const

export type ErrorNameEnum = (typeof ErrorNameEnum)[keyof typeof ErrorNameEnum]

/**
 *
 * @export
 * @interface ErrorResponseDto
 */
export interface ErrorResponseDto {
  /**
   * Status Code
   * @type {number}
   * @memberof ErrorResponseDto
   */
  statusCode: number
  /**
   * Detail error message
   * @type {string}
   * @memberof ErrorResponseDto
   */
  message: string
  /**
   *
   * @type {ErrorNameEnum}
   * @memberof ErrorResponseDto
   */
  errorName: ErrorNameEnum
}

/**
 *
 * @export
 * @interface EvidenceFileDto
 */
export interface EvidenceFileDto {
  /**
   * ID of the record in database.
   * @type {number}
   * @memberof EvidenceFileDto
   */
  id: number
  /**
   * UUID of the record.
   * @type {string}
   * @memberof EvidenceFileDto
   */
  uuid: string
  /**
   * Timestamp of creation in UTC.
   * @type {string}
   * @memberof EvidenceFileDto
   */
  createdAt: string
  /**
   * Timestamp of the latest update. Time is in UTC format.
   * @type {string}
   * @memberof EvidenceFileDto
   */
  updatedAt: string
  /**
   * System where record was created.
   * @type {string}
   * @memberof EvidenceFileDto
   */
  createdBy: string
  /**
   * System where record was updated.
   * @type {string}
   * @memberof EvidenceFileDto
   */
  updatedBy: string
  /**
   * Email address of author of the record.
   * @type {string}
   * @memberof EvidenceFileDto
   */
  createdByEmail?: string | null
  /**
   * Email address of the user who last updated the record.
   * @type {string}
   * @memberof EvidenceFileDto
   */
  updatedByEmail?: string | null
  /**
   * File path to the image from the root of the S3 bucket.
   * @type {string}
   * @memberof EvidenceFileDto
   */
  filePath: string
  /**
   *
   * @type {string}
   * @memberof EvidenceFileDto
   */
  fileName: string
  /**
   * ID of associated offence.
   * @type {number}
   * @memberof EvidenceFileDto
   */
  offenceId: number
}
/**
 *
 * @export
 * @interface HealthResponseDto
 */
export interface HealthResponseDto {
  /**
   *
   * @type {boolean}
   * @memberof HealthResponseDto
   */
  status: boolean
  /**
   *
   * @type {string}
   * @memberof HealthResponseDto
   */
  timestamp: string
}
/**
 *
 * @export
 * @interface MobileAppVersionUpdateDto
 */
export interface MobileAppVersionUpdateDto {
  /**
   * Version required from the user
   * @type {string}
   * @memberof MobileAppVersionUpdateDto
   */
  version: string
}
/**
 * Current status of offence.
 * @export
 * @enum {string}
 */

export const OffenceStateEnum = {
  Created: 'CREATED',
  Updated: 'UPDATED',
  Registered: 'REGISTERED',
  NotOffence: 'NOT_OFFENCE',
  BackofficeError: 'BACKOFFICE_ERROR',
  ConsumerError: 'CONSUMER_ERROR',
  PreparedToSend: 'PREPARED_TO_SEND',
  NotSend: 'NOT_SEND',
} as const

export type OffenceStateEnum = (typeof OffenceStateEnum)[keyof typeof OffenceStateEnum]

/**
 * Legal paragraph or regulation that was violated.
 * @export
 * @enum {string}
 */

export const OffenceTypeEnum = {
  A: 'A',
  B: 'B',
  C: 'C',
  D: 'D',
  E: 'E',
  F: 'F',
  G: 'G',
  H: 'H',
  I: 'I',
  J: 'J',
  K: 'K',
  L: 'L',
  M: 'M',
  N: 'N',
  O: 'O',
  P: 'P',
  Q: 'Q',
  R: 'R',
  S: 'S',
  T: 'T',
  U: 'U',
  Dz: 'DZ',
  NB: 'N_B',
  Zigzag: 'ZIGZAG',
} as const

export type OffenceTypeEnum = (typeof OffenceTypeEnum)[keyof typeof OffenceTypeEnum]

/**
 *
 * @export
 * @interface RequestCreateAutomaticScanDto
 */
export interface RequestCreateAutomaticScanDto {
  /**
   * Identifier of the scanning vehicle
   * @type {string}
   * @memberof RequestCreateAutomaticScanDto
   */
  patrol_vehicle_id: string
  /**
   * Azimuth angle of the scanning vehicle in degrees
   * @type {number}
   * @memberof RequestCreateAutomaticScanDto
   */
  patrol_vehicle_azimuth: number
  /**
   * Confidence level of the azimuth measurement
   * @type {number}
   * @memberof RequestCreateAutomaticScanDto
   */
  patrol_vehicle_azimuth_confidence: number
  /**
   * GPS position of the scanning vehicle
   * @type {object}
   * @memberof RequestCreateAutomaticScanDto
   */
  patrol_vehicle_position: object
  /**
   * Confidence level of the vehicle position
   * @type {number}
   * @memberof RequestCreateAutomaticScanDto
   */
  patrol_vehicle_position_confidence: number
  /**
   * ID of the scanning vehicle driver
   * @type {number}
   * @memberof RequestCreateAutomaticScanDto
   */
  patrol_vehicle_driver_id?: number
  /**
   * Unique identifier for the parked vehicle detection event
   * @type {string}
   * @memberof RequestCreateAutomaticScanDto
   */
  parked_vehicle_detection_id: string
  /**
   * Timestamp when the parked vehicle was detected
   * @type {string}
   * @memberof RequestCreateAutomaticScanDto
   */
  parked_vehicle_detection_timestamp: string
  /**
   * Confidence level of the parked vehicle detection
   * @type {number}
   * @memberof RequestCreateAutomaticScanDto
   */
  parked_vehicle_detection_confidence: number
  /**
   * GPS position of the front of the parked vehicle
   * @type {object}
   * @memberof RequestCreateAutomaticScanDto
   */
  parked_vehicle_front_position: object
  /**
   * GPS position of the rear of the parked vehicle
   * @type {object}
   * @memberof RequestCreateAutomaticScanDto
   */
  parked_vehicle_rear_position: object
  /**
   * Confidence level of the parked vehicle position
   * @type {number}
   * @memberof RequestCreateAutomaticScanDto
   */
  parked_vehicle_position_confidence: number
  /**
   * Type of the parked vehicle
   * @type {object}
   * @memberof RequestCreateAutomaticScanDto
   */
  parked_vehicle_type: object
  /**
   * Confidence level of the vehicle type classification
   * @type {number}
   * @memberof RequestCreateAutomaticScanDto
   */
  parked_vehicle_type_confidence: number
  /**
   * Identifier of the polygon where vehicle was detected
   * @type {string}
   * @memberof RequestCreateAutomaticScanDto
   */
  parked_vehicle_polygon_id?: string
  /**
   * Confidence level of the polygon detection
   * @type {number}
   * @memberof RequestCreateAutomaticScanDto
   */
  parked_vehicle_polygon_confidence?: number
  /**
   * License plate number of the parked vehicle
   * @type {string}
   * @memberof RequestCreateAutomaticScanDto
   */
  parked_vehicle_licence_plate: string
  /**
   * Confidence level of the license plate recognition
   * @type {number}
   * @memberof RequestCreateAutomaticScanDto
   */
  parked_vehicle_licence_plate_confidence: number
  /**
   * Camera operating mode
   * @type {object}
   * @memberof RequestCreateAutomaticScanDto
   */
  camera_mode: object
  /**
   * Identifier of the street entrance detection
   * @type {string}
   * @memberof RequestCreateAutomaticScanDto
   */
  street_entrance_detection_id?: string
  /**
   * Hash of the archived data
   * @type {string}
   * @memberof RequestCreateAutomaticScanDto
   */
  data_archive_hash: string
  /**
   * Metadata for captured images
   * @type {object}
   * @memberof RequestCreateAutomaticScanDto
   */
  data_image_metadata: object
}
/**
 *
 * @export
 * @interface RequestCreateOffenceDataDto
 */
export interface RequestCreateOffenceDataDto {
  /**
   * Date of offence
   * @type {string}
   * @memberof RequestCreateOffenceDataDto
   */
  createdAt?: string
  /**
   *
   * @type {OffenceTypeEnum}
   * @memberof RequestCreateOffenceDataDto
   */
  offenceType: OffenceTypeEnum
  /**
   * Set to false if the fine was paid on the spot to a police officer; true otherwise. For PAAS offences (offence types O, N, N_B), this value is always true.
   * @type {boolean}
   * @memberof RequestCreateOffenceDataDto
   */
  objectiveResponsibility: boolean
  /**
   * Longitude of the offence location. If different from the value in associated scan, it indicates the location was manually edited before creating the offence.
   * @type {number}
   * @memberof RequestCreateOffenceDataDto
   */
  long?: number
  /**
   * Latitude of the offence location. If different from the value in associated scan, it indicates the location was manually edited before creating the offence.
   * @type {number}
   * @memberof RequestCreateOffenceDataDto
   */
  lat?: number
  /**
   * Name of the street where the offence occurred. Typically provided only if the location was manually edited and differs from the associated scan.
   * @type {string}
   * @memberof RequestCreateOffenceDataDto
   */
  streetName?: string
  /**
   * UDR code (4-digit number or \"0\") for the offence location. Typically provided only if the UDR was manually edited and differs from the associated scan.
   * @type {string}
   * @memberof RequestCreateOffenceDataDto
   */
  udr?: string | null
  /**
   * Vehicle ID from NEV. Used to identify a specific vehicle when multiple vehicles share the same ECV.
   * @type {number}
   * @memberof RequestCreateOffenceDataDto
   */
  vehicleId?: number
  /**
   *
   * @type {ResolutionOffenceTypeEnum}
   * @memberof RequestCreateOffenceDataDto
   */
  resolutionType?: ResolutionOffenceTypeEnum
  /**
   * ID of zone sign photo in database.
   * @type {number}
   * @memberof RequestCreateOffenceDataDto
   */
  zoneSignPhotoId?: number
}

/**
 *
 * @export
 * @interface RequestCreateOrUpdateScanDto
 */
export interface RequestCreateOrUpdateScanDto {
  /**
   * Date of offence
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  createdAt?: string
  /**
   * UUID of the scan to update. If not provided, a new scan will be created.
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  uuid?: string
  /**
   * Vehicle license plate.
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  ecv: string
  /**
   * Longitude of the scan location.
   * @type {number}
   * @memberof RequestCreateOrUpdateScanDto
   */
  long: number
  /**
   * Latitude of the scan location.
   * @type {number}
   * @memberof RequestCreateOrUpdateScanDto
   */
  lat: number
  /**
   * Flag indicating whether the ECV was automatically recognized from a photo or entered manually.
   * @type {boolean}
   * @memberof RequestCreateOrUpdateScanDto
   */
  ecvUpdatedManually?: boolean
  /**
   *
   * @type {ScanReasonEnum}
   * @memberof RequestCreateOrUpdateScanDto
   */
  scanReason: ScanReasonEnum
  /**
   * UDR code (4-digit number or \"0\") for the offence location.
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  udr?: string | null
  /**
   * Name of the street where the scan was performed.
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  streetName?: string | null
  /**
   * Name of the district where the scan was performed.
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  district?: string | null
  /**
   * Name of the zone area where the scan was performed.
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  areaName?: string | null
  /**
   * Array of area codes associated with the scan location.
   * @type {Array<string>}
   * @memberof RequestCreateOrUpdateScanDto
   */
  areaCodes?: Array<string> | null
  /**
   * Externally generated UUID of the UDR.
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  udrGlobalId?: string | null
  /**
   * Version of the mobile application used to perform the scan.
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  mobileAppVersion?: string | null
  /**
   * Unique identifier of the device used to perform the scan.
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  deviceId?: string | null
}

/**
 *
 * @export
 * @interface RequestCreateSignPostScanDto
 */
export interface RequestCreateSignPostScanDto {
  /**
   * Identifier of the scanning vehicle
   * @type {string}
   * @memberof RequestCreateSignPostScanDto
   */
  patrol_vehicle_id: string
  /**
   * Azimuth angle of the scanning vehicle in degrees
   * @type {number}
   * @memberof RequestCreateSignPostScanDto
   */
  patrol_vehicle_azimuth: number
  /**
   * Confidence level of the azimuth measurement
   * @type {number}
   * @memberof RequestCreateSignPostScanDto
   */
  patrol_vehicle_azimuth_confidence: number
  /**
   * GPS position of the scanning vehicle
   * @type {object}
   * @memberof RequestCreateSignPostScanDto
   */
  patrol_vehicle_position: object
  /**
   * Confidence level of the vehicle position
   * @type {number}
   * @memberof RequestCreateSignPostScanDto
   */
  patrol_vehicle_position_confidence: number
  /**
   * ID of the scanning vehicle driver
   * @type {number}
   * @memberof RequestCreateSignPostScanDto
   */
  patrol_vehicle_driver_id?: number
  /**
   * Unique identifier for the sign post detection event
   * @type {string}
   * @memberof RequestCreateSignPostScanDto
   */
  sign_post_detection_id: string
  /**
   * Timestamp when the sign post was detected
   * @type {string}
   * @memberof RequestCreateSignPostScanDto
   */
  sign_post_detection_timestamp: string
  /**
   * Unique identifier of the detected sign post
   * @type {string}
   * @memberof RequestCreateSignPostScanDto
   */
  sign_post_id: string
  /**
   * Confidence level of the sign post detection
   * @type {number}
   * @memberof RequestCreateSignPostScanDto
   */
  sign_post_detection_confidence: number
  /**
   * Camera operating mode
   * @type {object}
   * @memberof RequestCreateSignPostScanDto
   */
  camera_mode: object
  /**
   * Hash of the archived data
   * @type {string}
   * @memberof RequestCreateSignPostScanDto
   */
  data_archive_hash: string
  /**
   * Metadata for captured images
   * @type {object}
   * @memberof RequestCreateSignPostScanDto
   */
  data_image_metadata: object
}
/**
 *
 * @export
 * @interface RequestCreateStreetDetectionDto
 */
export interface RequestCreateStreetDetectionDto {
  /**
   * Unique identifier for the street detection event
   * @type {string}
   * @memberof RequestCreateStreetDetectionDto
   */
  street_detection_id: string
  /**
   * Timestamp when the street was detected
   * @type {string}
   * @memberof RequestCreateStreetDetectionDto
   */
  timestamp: string
  /**
   * Identifier of the scanning vehicle
   * @type {string}
   * @memberof RequestCreateStreetDetectionDto
   */
  patrol_vehicle_id: string
  /**
   * Identifier of the detected street segment
   * @type {string}
   * @memberof RequestCreateStreetDetectionDto
   */
  street_segment_id: string
  /**
   * Indicates if the vehicle is driving in the reverse direction of the street
   * @type {boolean}
   * @memberof RequestCreateStreetDetectionDto
   */
  is_reverse_drive: boolean
}
/**
 * Type of offence resolution. Applicable only if subjective responsibility is assigned.
 * @export
 * @enum {string}
 */

export const ResolutionOffenceTypeEnum = {
  JustRegistration: 'JUST_REGISTRATION',
  UnjustifiedReport: 'UNJUSTIFIED_REPORT',
  NotCaught: 'NOT_CAUGHT',
  BlockingDevice: 'BLOCKING_DEVICE',
  Fine: 'FINE',
  SewedUp: 'SEWED_UP',
  Notification: 'NOTIFICATION',
  ForwardedToDi: 'FORWARDED_TO_DI',
} as const

export type ResolutionOffenceTypeEnum =
  (typeof ResolutionOffenceTypeEnum)[keyof typeof ResolutionOffenceTypeEnum]

/**
 *
 * @export
 * @interface ResponseBaseOffenceDto
 */
export interface ResponseBaseOffenceDto {
  /**
   * ID of the record in database.
   * @type {number}
   * @memberof ResponseBaseOffenceDto
   */
  id: number
  /**
   * UUID of the record.
   * @type {string}
   * @memberof ResponseBaseOffenceDto
   */
  uuid: string
  /**
   * Timestamp of creation in UTC.
   * @type {string}
   * @memberof ResponseBaseOffenceDto
   */
  createdAt: string
  /**
   * Timestamp of the latest update. Time is in UTC format.
   * @type {string}
   * @memberof ResponseBaseOffenceDto
   */
  updatedAt: string
  /**
   * System where record was created.
   * @type {string}
   * @memberof ResponseBaseOffenceDto
   */
  createdBy: string
  /**
   * System where record was updated.
   * @type {string}
   * @memberof ResponseBaseOffenceDto
   */
  updatedBy: string
  /**
   * Email address of author of the record.
   * @type {string}
   * @memberof ResponseBaseOffenceDto
   */
  createdByEmail?: string | null
  /**
   * Email address of the user who last updated the record.
   * @type {string}
   * @memberof ResponseBaseOffenceDto
   */
  updatedByEmail?: string | null
  /**
   *
   * @type {OffenceTypeEnum}
   * @memberof ResponseBaseOffenceDto
   */
  offenceType: OffenceTypeEnum
  /**
   * Set to false if the fine was paid on the spot to a police officer; true otherwise. For PAAS offences (offence types O, N, N_B), this value is always true.
   * @type {boolean}
   * @memberof ResponseBaseOffenceDto
   */
  objectiveResponsibility: boolean
  /**
   *
   * @type {OffenceStateEnum}
   * @memberof ResponseBaseOffenceDto
   */
  offenceState: OffenceStateEnum
  /**
   * ID of scan associated with this offence.
   * @type {number}
   * @memberof ResponseBaseOffenceDto
   */
  scanVehicleId: number
  /**
   * Vehicle ID from NEV. Used to separate multiple vehicles with same ECV.
   * @type {string}
   * @memberof ResponseBaseOffenceDto
   */
  registryVehicleId: string | null
  /**
   * ID of zone sign photo associated with this offence.
   * @type {number}
   * @memberof ResponseBaseOffenceDto
   */
  zoneSignPhotoId: number | null
  /**
   *
   * @type {ResponseCreateOrUpdateScanDto}
   * @memberof ResponseBaseOffenceDto
   */
  ScanVehicle: ResponseCreateOrUpdateScanDto
  /**
   *
   * @type {object}
   * @memberof ResponseBaseOffenceDto
   */
  offenceResolution: object | null
  /**
   *
   * @type {object}
   * @memberof ResponseBaseOffenceDto
   */
  auditorGroup: object | null
  /**
   *
   * @type {number}
   * @memberof ResponseBaseOffenceDto
   */
  retryAttempt: number | null
}

/**
 *
 * @export
 * @interface ResponseCardDto
 */
export interface ResponseCardDto {
  /**
   * UUID of card in Parkdots.
   * @type {string}
   * @memberof ResponseCardDto
   */
  id: string
  /**
   * Vehicle license plate.
   * @type {string}
   * @memberof ResponseCardDto
   */
  cardSubject: string
  /**
   *
   * @type {string}
   * @memberof ResponseCardDto
   */
  state: ResponseCardDtoStateEnum
  /**
   * Type of parking card.
   * @type {string}
   * @memberof ResponseCardDto
   */
  cardSchemeName: string
}

export const ResponseCardDtoStateEnum = {
  Valid: 'VALID',
  Invalid: 'INVALID',
  Verified: 'VERIFIED',
  Expired: 'EXPIRED',
  Canceled: 'CANCELED',
} as const

export type ResponseCardDtoStateEnum =
  (typeof ResponseCardDtoStateEnum)[keyof typeof ResponseCardDtoStateEnum]

/**
 *
 * @export
 * @interface ResponseCreateOffenceDto
 */
export interface ResponseCreateOffenceDto {
  /**
   * ID of the record in database.
   * @type {number}
   * @memberof ResponseCreateOffenceDto
   */
  id: number
  /**
   * UUID of the record.
   * @type {string}
   * @memberof ResponseCreateOffenceDto
   */
  uuid: string
  /**
   * Timestamp of creation in UTC.
   * @type {string}
   * @memberof ResponseCreateOffenceDto
   */
  createdAt: string
  /**
   * Timestamp of the latest update. Time is in UTC format.
   * @type {string}
   * @memberof ResponseCreateOffenceDto
   */
  updatedAt: string
  /**
   * System where record was created.
   * @type {string}
   * @memberof ResponseCreateOffenceDto
   */
  createdBy: string
  /**
   * System where record was updated.
   * @type {string}
   * @memberof ResponseCreateOffenceDto
   */
  updatedBy: string
  /**
   * Email address of author of the record.
   * @type {string}
   * @memberof ResponseCreateOffenceDto
   */
  createdByEmail?: string | null
  /**
   * Email address of the user who last updated the record.
   * @type {string}
   * @memberof ResponseCreateOffenceDto
   */
  updatedByEmail?: string | null
  /**
   *
   * @type {OffenceTypeEnum}
   * @memberof ResponseCreateOffenceDto
   */
  offenceType: OffenceTypeEnum
  /**
   * Set to false if the fine was paid on the spot to a police officer; true otherwise. For PAAS offences (offence types O, N, N_B), this value is always true.
   * @type {boolean}
   * @memberof ResponseCreateOffenceDto
   */
  objectiveResponsibility: boolean
  /**
   *
   * @type {OffenceStateEnum}
   * @memberof ResponseCreateOffenceDto
   */
  offenceState: OffenceStateEnum
  /**
   * ID of scan associated with this offence.
   * @type {number}
   * @memberof ResponseCreateOffenceDto
   */
  scanVehicleId: number
  /**
   * Vehicle ID from NEV. Used to separate multiple vehicles with same ECV.
   * @type {string}
   * @memberof ResponseCreateOffenceDto
   */
  registryVehicleId: string | null
  /**
   * ID of zone sign photo associated with this offence.
   * @type {number}
   * @memberof ResponseCreateOffenceDto
   */
  zoneSignPhotoId: number | null
  /**
   *
   * @type {ResponseCreateOrUpdateScanDto}
   * @memberof ResponseCreateOffenceDto
   */
  ScanVehicle: ResponseCreateOrUpdateScanDto
  /**
   *
   * @type {object}
   * @memberof ResponseCreateOffenceDto
   */
  offenceResolution: object | null
  /**
   *
   * @type {object}
   * @memberof ResponseCreateOffenceDto
   */
  auditorGroup: object | null
  /**
   *
   * @type {number}
   * @memberof ResponseCreateOffenceDto
   */
  retryAttempt: number | null
  /**
   *
   * @type {ResponseZoneSignPhotoDto}
   * @memberof ResponseCreateOffenceDto
   */
  ZoneSignPhoto: ResponseZoneSignPhotoDto | null
  /**
   *
   * @type {Array<EvidenceFileDto>}
   * @memberof ResponseCreateOffenceDto
   */
  EvidenceFile: Array<EvidenceFileDto>
}

/**
 *
 * @export
 * @interface ResponseCreateOrUpdateScanDto
 */
export interface ResponseCreateOrUpdateScanDto {
  /**
   * Timestamp of creation in UTC.
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  createdAt?: string
  /**
   * UUID of the record.
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  uuid?: string
  /**
   * Vehicle license plate.
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  ecv: string
  /**
   * Longitude of the scan location.
   * @type {number}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  long: number
  /**
   * Latitude of the scan location.
   * @type {number}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  lat: number
  /**
   * Flag indicating whether the ECV was automatically recognized from a photo or entered manually.
   * @type {boolean}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  ecvUpdatedManually?: boolean
  /**
   *
   * @type {ScanReasonEnum}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  scanReason: ScanReasonEnum
  /**
   * UDR code (4-digit number or \"0\") for the offence location.
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  udr?: string | null
  /**
   * Name of the street where the scan was performed.
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  streetName?: string | null
  /**
   * Name of the district where the scan was performed.
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  district?: string | null
  /**
   * Name of the zone area where the scan was performed.
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  areaName?: string | null
  /**
   * Array of area codes associated with the scan location.
   * @type {Array<string>}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  areaCodes?: Array<string> | null
  /**
   * Externally generated UUID of the UDR.
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  udrGlobalId?: string | null
  /**
   * Version of the mobile application used to perform the scan.
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  mobileAppVersion?: string | null
  /**
   * Unique identifier of the device used to perform the scan.
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  deviceId?: string | null
  /**
   * ID of the record in database.
   * @type {number}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  id: number
  /**
   * Timestamp of the latest update. Time is in UTC format.
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  updatedAt: string
  /**
   * System where record was created.
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  createdBy: string
  /**
   * System where record was updated.
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  updatedBy: string
  /**
   * Email address of author of the record.
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  createdByEmail?: string | null
  /**
   * Email address of the user who last updated the record.
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  updatedByEmail?: string | null
  /**
   *
   * @type {ScanResultEnum}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  scanResult?: ScanResultEnum
}

/**
 *
 * @export
 * @interface ResponseGetOffenceOverviewDto
 */
export interface ResponseGetOffenceOverviewDto {
  /**
   * Vehicle license plate.
   * @type {string}
   * @memberof ResponseGetOffenceOverviewDto
   */
  ecv: string
  /**
   * Timestamp of creation in UTC.
   * @type {string}
   * @memberof ResponseGetOffenceOverviewDto
   */
  createdAt: string
  /**
   *
   * @type {OffenceTypeEnum}
   * @memberof ResponseGetOffenceOverviewDto
   */
  offenceType: OffenceTypeEnum
  /**
   * UDR code (4-digit number or \"0\") for the offence location.
   * @type {string}
   * @memberof ResponseGetOffenceOverviewDto
   */
  udr?: string | null
  /**
   * Flag indicating whether the offence was automatically cancelled by system recheck of a parking authorization after preconfigured time.
   * @type {boolean}
   * @memberof ResponseGetOffenceOverviewDto
   */
  isAutoCancelled: boolean
}

/**
 *
 * @export
 * @interface ResponseGetOffenceOverviewListDto
 */
export interface ResponseGetOffenceOverviewListDto {
  /**
   *
   * @type {Array<ResponseGetOffenceOverviewDto>}
   * @memberof ResponseGetOffenceOverviewListDto
   */
  offences: Array<ResponseGetOffenceOverviewDto>
}
/**
 *
 * @export
 * @interface ResponseGetZoneSignPhotosDto
 */
export interface ResponseGetZoneSignPhotosDto {
  /**
   *
   * @type {Array<ResponseZoneSignPhotoPropertiesDto>}
   * @memberof ResponseGetZoneSignPhotosDto
   */
  photos: Array<ResponseZoneSignPhotoPropertiesDto>
}
/**
 *
 * @export
 * @interface ResponseTicketDto
 */
export interface ResponseTicketDto {
  /**
   * UUID of parking ticket from Pricing API.
   * @type {string}
   * @memberof ResponseTicketDto
   */
  id: string
  /**
   * UDR code (4-digit number) of the parking ticket.
   * @type {string}
   * @memberof ResponseTicketDto
   */
  udr: string
  /**
   * Flag indicating whether the parking ticket was active at the specified time.
   * @type {boolean}
   * @memberof ResponseTicketDto
   */
  isValid: boolean
}
/**
 *
 * @export
 * @interface ResponseTicketsAndPermitsDto
 */
export interface ResponseTicketsAndPermitsDto {
  /**
   *
   * @type {Array<ResponseTicketDto>}
   * @memberof ResponseTicketsAndPermitsDto
   */
  tickets: Array<ResponseTicketDto>
  /**
   *
   * @type {Array<ResponseCardDto>}
   * @memberof ResponseTicketsAndPermitsDto
   */
  permitCards: Array<ResponseCardDto>
}
/**
 *
 * @export
 * @interface ResponseVehiclePropertiesDto
 */
export interface ResponseVehiclePropertiesDto {
  /**
   * List of vehicles for one license plate containing basic properties like color or brand of vehicle.
   * @type {Array<ResponseVehiclePropertiesItemDto>}
   * @memberof ResponseVehiclePropertiesDto
   */
  items: Array<ResponseVehiclePropertiesItemDto>
}
/**
 *
 * @export
 * @interface ResponseVehiclePropertiesItemDto
 */
export interface ResponseVehiclePropertiesItemDto {
  /**
   * Color of vehicle from NEV registry.
   * @type {string}
   * @memberof ResponseVehiclePropertiesItemDto
   */
  color?: string
  /**
   * Brand of vehicle from NEV registry.
   * @type {string}
   * @memberof ResponseVehiclePropertiesItemDto
   */
  brand?: string
  /**
   * Type of vehicle.
   * @type {string}
   * @memberof ResponseVehiclePropertiesItemDto
   */
  vehicleType?: string
  /**
   * ID of vehicle from NEV registry.
   * @type {number}
   * @memberof ResponseVehiclePropertiesItemDto
   */
  vehicleId: number
}
/**
 *
 * @export
 * @interface ResponseZoneSignPhotoDto
 */
export interface ResponseZoneSignPhotoDto {
  /**
   * ID of the record in database.
   * @type {number}
   * @memberof ResponseZoneSignPhotoDto
   */
  id: number
  /**
   * UUID of the record.
   * @type {string}
   * @memberof ResponseZoneSignPhotoDto
   */
  uuid: string
  /**
   * Timestamp of creation in UTC.
   * @type {string}
   * @memberof ResponseZoneSignPhotoDto
   */
  createdAt: string
  /**
   * Timestamp of the latest update. Time is in UTC format.
   * @type {string}
   * @memberof ResponseZoneSignPhotoDto
   */
  updatedAt: string
  /**
   * System where record was created.
   * @type {string}
   * @memberof ResponseZoneSignPhotoDto
   */
  createdBy: string
  /**
   * System where record was updated.
   * @type {string}
   * @memberof ResponseZoneSignPhotoDto
   */
  updatedBy: string
  /**
   * Email address of author of the record.
   * @type {string}
   * @memberof ResponseZoneSignPhotoDto
   */
  createdByEmail?: string | null
  /**
   * Email address of the user who last updated the record.
   * @type {string}
   * @memberof ResponseZoneSignPhotoDto
   */
  updatedByEmail?: string | null
  /**
   * UUID of zone sign from GIS data.
   * @type {string}
   * @memberof ResponseZoneSignPhotoDto
   */
  globalId?: string | null
  /**
   * Arbitrary info about image, e.g. UDR number.
   * @type {string}
   * @memberof ResponseZoneSignPhotoDto
   */
  tag?: string | null
  /**
   * Latitude of image.
   * @type {number}
   * @memberof ResponseZoneSignPhotoDto
   */
  lat?: number | null
  /**
   * Longitude of image.
   * @type {number}
   * @memberof ResponseZoneSignPhotoDto
   */
  long?: number | null
  /**
   *
   * @type {string}
   * @memberof ResponseZoneSignPhotoDto
   */
  photoUrl: string
}
/**
 *
 * @export
 * @interface ResponseZoneSignPhotoPropertiesDto
 */
export interface ResponseZoneSignPhotoPropertiesDto {
  /**
   * UUID of zone sign from GIS data.
   * @type {string}
   * @memberof ResponseZoneSignPhotoPropertiesDto
   */
  globalId?: string | null
  /**
   * Arbitrary info about image, e.g. UDR number.
   * @type {string}
   * @memberof ResponseZoneSignPhotoPropertiesDto
   */
  tag?: string | null
  /**
   * Latitude of image.
   * @type {number}
   * @memberof ResponseZoneSignPhotoPropertiesDto
   */
  lat?: number | null
  /**
   * Longitude of image.
   * @type {number}
   * @memberof ResponseZoneSignPhotoPropertiesDto
   */
  long?: number | null
  /**
   *
   * @type {string}
   * @memberof ResponseZoneSignPhotoPropertiesDto
   */
  photoUrl: string
  /**
   * ID of the record in database.
   * @type {number}
   * @memberof ResponseZoneSignPhotoPropertiesDto
   */
  id: number
}
/**
 *
 * @export
 * @interface RideEventDto
 */
export interface RideEventDto {
  /**
   * Unique ID of the driver shift event
   * @type {string}
   * @memberof RideEventDto
   */
  driver_shift_event_id: string
  /**
   * Unique ID of the driver
   * @type {number}
   * @memberof RideEventDto
   */
  driver_id: number
  /**
   * Timestamp of the shift event in ISO format
   * @type {string}
   * @memberof RideEventDto
   */
  timestamp: string
}
/**
 * Reason for the scan. For example, if set to PAAS_PARKING_AUTHORIZATION, the system will check whether the specified ECV is authorized to park in the given UDR.
 * @export
 * @enum {string}
 */

export const ScanReasonEnum = {
  PaasParkingAuthorization: 'PAAS_PARKING_AUTHORIZATION',
  Research: 'RESEARCH',
  Testing: 'TESTING',
  Other: 'OTHER',
} as const

export type ScanReasonEnum = (typeof ScanReasonEnum)[keyof typeof ScanReasonEnum]

/**
 * Used to flag duplicity and PAAS parking violation. By default returns NO_VIOLATION / OTHER when PAAS_PARKING_AUTHORIZATION / OTHER scan reason set
 * @export
 * @enum {string}
 */

export const ScanResultEnum = {
  PaasParkingViolation: 'PAAS_PARKING_VIOLATION',
  PaasParkingViolationDuplicity: 'PAAS_PARKING_VIOLATION_DUPLICITY',
  Other: 'OTHER',
  NoViolation: 'NO_VIOLATION',
  LowConfidence: 'LOW_CONFIDENCE',
} as const

export type ScanResultEnum = (typeof ScanResultEnum)[keyof typeof ScanResultEnum]

/**
 *
 * @export
 * @interface SignPostEvidenceDto
 */
export interface SignPostEvidenceDto {
  /**
   * Unique ID of specific traffic sign detection
   * @type {string}
   * @memberof SignPostEvidenceDto
   */
  sign_post_detection_id: string
  /**
   * Path to evidence archive
   * @type {string}
   * @memberof SignPostEvidenceDto
   */
  data_archive_path: string
}
/**
 *
 * @export
 * @interface SuccessResponseDto
 */
export interface SuccessResponseDto {
  /**
   *
   * @type {string}
   * @memberof SuccessResponseDto
   */
  message: string
}
/**
 *
 * @export
 * @interface TokenResponseDto
 */
export interface TokenResponseDto {
  /**
   * The access token for API authentication
   * @type {string}
   * @memberof TokenResponseDto
   */
  access_token: string
  /**
   * Type of the token
   * @type {string}
   * @memberof TokenResponseDto
   */
  token_type: string
  /**
   * Token expiration time in seconds
   * @type {number}
   * @memberof TokenResponseDto
   */
  expires_in: number
  /**
   * Scope of the access token
   * @type {string}
   * @memberof TokenResponseDto
   */
  scope?: string
}
/**
 *
 * @export
 * @interface VehicleDetectionResponseDto
 */
export interface VehicleDetectionResponseDto {
  /**
   * Flag whether to keep the evidence data for this detection.
   * @type {boolean}
   * @memberof VehicleDetectionResponseDto
   */
  keep_evidence_data: boolean
}
/**
 *
 * @export
 * @interface VehicleEvidenceDto
 */
export interface VehicleEvidenceDto {
  /**
   * Unique ID of specific parked vehicle detection
   * @type {string}
   * @memberof VehicleEvidenceDto
   */
  parked_vehicle_detection_id: string
  /**
   * Path to evidence archive
   * @type {string}
   * @memberof VehicleEvidenceDto
   */
  data_archive_path: string
}
/**
 *
 * @export
 * @interface VersionResponse
 */
export interface VersionResponse {
  /**
   * API version
   * @type {string}
   * @memberof VersionResponse
   */
  version: string
  /**
   * Current server timestamp
   * @type {string}
   * @memberof VersionResponse
   */
  timestamp: string
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary OAuth2 token endpoint
     * @param {string} grantType OAuth2 grant type
     * @param {string} clientId Client identifier for testing environment
     * @param {string} clientSecret Client secret for testing environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitAuthenticationControllerGetAccessToken: async (
      grantType: string,
      clientId: string,
      clientSecret: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'grantType' is not null or undefined
      assertParamExists('iteraitAuthenticationControllerGetAccessToken', 'grantType', grantType)
      // verify required parameter 'clientId' is not null or undefined
      assertParamExists('iteraitAuthenticationControllerGetAccessToken', 'clientId', clientId)
      // verify required parameter 'clientSecret' is not null or undefined
      assertParamExists(
        'iteraitAuthenticationControllerGetAccessToken',
        'clientSecret',
        clientSecret,
      )
      const localVarPath = `/token`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new URLSearchParams()

      if (grantType !== undefined) {
        localVarFormParams.set('grant_type', grantType as any)
      }

      if (clientId !== undefined) {
        localVarFormParams.set('client_id', clientId as any)
      }

      if (clientSecret !== undefined) {
        localVarFormParams.set('client_secret', clientSecret as any)
      }

      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams.toString()

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary OAuth2 token endpoint
     * @param {string} grantType OAuth2 grant type
     * @param {string} clientId Client identifier for testing environment
     * @param {string} clientSecret Client secret for testing environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iteraitAuthenticationControllerGetAccessToken(
      grantType: string,
      clientId: string,
      clientSecret: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iteraitAuthenticationControllerGetAccessToken(
          grantType,
          clientId,
          clientSecret,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthenticationApi.iteraitAuthenticationControllerGetAccessToken']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthenticationApiFp(configuration)
  return {
    /**
     *
     * @summary OAuth2 token endpoint
     * @param {string} grantType OAuth2 grant type
     * @param {string} clientId Client identifier for testing environment
     * @param {string} clientSecret Client secret for testing environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitAuthenticationControllerGetAccessToken(
      grantType: string,
      clientId: string,
      clientSecret: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<TokenResponseDto> {
      return localVarFp
        .iteraitAuthenticationControllerGetAccessToken(grantType, clientId, clientSecret, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
  /**
   *
   * @summary OAuth2 token endpoint
   * @param {string} grantType OAuth2 grant type
   * @param {string} clientId Client identifier for testing environment
   * @param {string} clientSecret Client secret for testing environment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public iteraitAuthenticationControllerGetAccessToken(
    grantType: string,
    clientId: string,
    clientSecret: string,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthenticationApiFp(this.configuration)
      .iteraitAuthenticationControllerGetAccessToken(grantType, clientId, clientSecret, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    defaultControllerHealthcheck: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async defaultControllerHealthcheck(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultResponseHealthcheck>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.defaultControllerHealthcheck(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.defaultControllerHealthcheck']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    defaultControllerHealthcheck(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DefaultResponseHealthcheck> {
      return localVarFp
        .defaultControllerHealthcheck(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * See if nest is working!
   * @summary Healthcheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public defaultControllerHealthcheck(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .defaultControllerHealthcheck(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DetectionSubmissionApi - axios parameter creator
 * @export
 */
export const DetectionSubmissionApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Submit parked vehicle detection data
     * @param {RequestCreateAutomaticScanDto} requestCreateAutomaticScanDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitDetectionControllerScan: async (
      requestCreateAutomaticScanDto: RequestCreateAutomaticScanDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestCreateAutomaticScanDto' is not null or undefined
      assertParamExists(
        'iteraitDetectionControllerScan',
        'requestCreateAutomaticScanDto',
        requestCreateAutomaticScanDto,
      )
      const localVarPath = `/vehicle-detection`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestCreateAutomaticScanDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Submit real-time sign post detection data from patrol vehicles.
     * @summary Submit sign post detection data.
     * @param {RequestCreateSignPostScanDto} requestCreateSignPostScanDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitDetectionControllerStoreZoneSignPhoto: async (
      requestCreateSignPostScanDto: RequestCreateSignPostScanDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestCreateSignPostScanDto' is not null or undefined
      assertParamExists(
        'iteraitDetectionControllerStoreZoneSignPhoto',
        'requestCreateSignPostScanDto',
        requestCreateSignPostScanDto,
      )
      const localVarPath = `/sign-post-detection`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestCreateSignPostScanDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Submit vehicle evidence data with archive information.
     * @summary Submit vehicle evidence data.
     * @param {RequestCreateStreetDetectionDto} requestCreateStreetDetectionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitDetectionControllerStreetEntrance: async (
      requestCreateStreetDetectionDto: RequestCreateStreetDetectionDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestCreateStreetDetectionDto' is not null or undefined
      assertParamExists(
        'iteraitDetectionControllerStreetEntrance',
        'requestCreateStreetDetectionDto',
        requestCreateStreetDetectionDto,
      )
      const localVarPath = `/street-entrance-detection`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestCreateStreetDetectionDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Submit sign post evidence data with archive information.
     * @summary Submit sign post evidence data.
     * @param {RequestCreateStreetDetectionDto} requestCreateStreetDetectionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitDetectionControllerStreetExit: async (
      requestCreateStreetDetectionDto: RequestCreateStreetDetectionDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestCreateStreetDetectionDto' is not null or undefined
      assertParamExists(
        'iteraitDetectionControllerStreetExit',
        'requestCreateStreetDetectionDto',
        requestCreateStreetDetectionDto,
      )
      const localVarPath = `/street-exit-detection`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestCreateStreetDetectionDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DetectionSubmissionApi - functional programming interface
 * @export
 */
export const DetectionSubmissionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DetectionSubmissionApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Submit parked vehicle detection data
     * @param {RequestCreateAutomaticScanDto} requestCreateAutomaticScanDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iteraitDetectionControllerScan(
      requestCreateAutomaticScanDto: RequestCreateAutomaticScanDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDetectionResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.iteraitDetectionControllerScan(
        requestCreateAutomaticScanDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DetectionSubmissionApi.iteraitDetectionControllerScan']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Submit real-time sign post detection data from patrol vehicles.
     * @summary Submit sign post detection data.
     * @param {RequestCreateSignPostScanDto} requestCreateSignPostScanDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iteraitDetectionControllerStoreZoneSignPhoto(
      requestCreateSignPostScanDto: RequestCreateSignPostScanDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iteraitDetectionControllerStoreZoneSignPhoto(
          requestCreateSignPostScanDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DetectionSubmissionApi.iteraitDetectionControllerStoreZoneSignPhoto']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Submit vehicle evidence data with archive information.
     * @summary Submit vehicle evidence data.
     * @param {RequestCreateStreetDetectionDto} requestCreateStreetDetectionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iteraitDetectionControllerStreetEntrance(
      requestCreateStreetDetectionDto: RequestCreateStreetDetectionDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iteraitDetectionControllerStreetEntrance(
          requestCreateStreetDetectionDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DetectionSubmissionApi.iteraitDetectionControllerStreetEntrance']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Submit sign post evidence data with archive information.
     * @summary Submit sign post evidence data.
     * @param {RequestCreateStreetDetectionDto} requestCreateStreetDetectionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iteraitDetectionControllerStreetExit(
      requestCreateStreetDetectionDto: RequestCreateStreetDetectionDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iteraitDetectionControllerStreetExit(
          requestCreateStreetDetectionDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DetectionSubmissionApi.iteraitDetectionControllerStreetExit']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * DetectionSubmissionApi - factory interface
 * @export
 */
export const DetectionSubmissionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DetectionSubmissionApiFp(configuration)
  return {
    /**
     *
     * @summary Submit parked vehicle detection data
     * @param {RequestCreateAutomaticScanDto} requestCreateAutomaticScanDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitDetectionControllerScan(
      requestCreateAutomaticScanDto: RequestCreateAutomaticScanDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<VehicleDetectionResponseDto> {
      return localVarFp
        .iteraitDetectionControllerScan(requestCreateAutomaticScanDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Submit real-time sign post detection data from patrol vehicles.
     * @summary Submit sign post detection data.
     * @param {RequestCreateSignPostScanDto} requestCreateSignPostScanDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitDetectionControllerStoreZoneSignPhoto(
      requestCreateSignPostScanDto: RequestCreateSignPostScanDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SuccessResponseDto> {
      return localVarFp
        .iteraitDetectionControllerStoreZoneSignPhoto(requestCreateSignPostScanDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Submit vehicle evidence data with archive information.
     * @summary Submit vehicle evidence data.
     * @param {RequestCreateStreetDetectionDto} requestCreateStreetDetectionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitDetectionControllerStreetEntrance(
      requestCreateStreetDetectionDto: RequestCreateStreetDetectionDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SuccessResponseDto> {
      return localVarFp
        .iteraitDetectionControllerStreetEntrance(requestCreateStreetDetectionDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Submit sign post evidence data with archive information.
     * @summary Submit sign post evidence data.
     * @param {RequestCreateStreetDetectionDto} requestCreateStreetDetectionDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitDetectionControllerStreetExit(
      requestCreateStreetDetectionDto: RequestCreateStreetDetectionDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SuccessResponseDto> {
      return localVarFp
        .iteraitDetectionControllerStreetExit(requestCreateStreetDetectionDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DetectionSubmissionApi - object-oriented interface
 * @export
 * @class DetectionSubmissionApi
 * @extends {BaseAPI}
 */
export class DetectionSubmissionApi extends BaseAPI {
  /**
   *
   * @summary Submit parked vehicle detection data
   * @param {RequestCreateAutomaticScanDto} requestCreateAutomaticScanDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DetectionSubmissionApi
   */
  public iteraitDetectionControllerScan(
    requestCreateAutomaticScanDto: RequestCreateAutomaticScanDto,
    options?: RawAxiosRequestConfig,
  ) {
    return DetectionSubmissionApiFp(this.configuration)
      .iteraitDetectionControllerScan(requestCreateAutomaticScanDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Submit real-time sign post detection data from patrol vehicles.
   * @summary Submit sign post detection data.
   * @param {RequestCreateSignPostScanDto} requestCreateSignPostScanDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DetectionSubmissionApi
   */
  public iteraitDetectionControllerStoreZoneSignPhoto(
    requestCreateSignPostScanDto: RequestCreateSignPostScanDto,
    options?: RawAxiosRequestConfig,
  ) {
    return DetectionSubmissionApiFp(this.configuration)
      .iteraitDetectionControllerStoreZoneSignPhoto(requestCreateSignPostScanDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Submit vehicle evidence data with archive information.
   * @summary Submit vehicle evidence data.
   * @param {RequestCreateStreetDetectionDto} requestCreateStreetDetectionDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DetectionSubmissionApi
   */
  public iteraitDetectionControllerStreetEntrance(
    requestCreateStreetDetectionDto: RequestCreateStreetDetectionDto,
    options?: RawAxiosRequestConfig,
  ) {
    return DetectionSubmissionApiFp(this.configuration)
      .iteraitDetectionControllerStreetEntrance(requestCreateStreetDetectionDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Submit sign post evidence data with archive information.
   * @summary Submit sign post evidence data.
   * @param {RequestCreateStreetDetectionDto} requestCreateStreetDetectionDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DetectionSubmissionApi
   */
  public iteraitDetectionControllerStreetExit(
    requestCreateStreetDetectionDto: RequestCreateStreetDetectionDto,
    options?: RawAxiosRequestConfig,
  ) {
    return DetectionSubmissionApiFp(this.configuration)
      .iteraitDetectionControllerStreetExit(requestCreateStreetDetectionDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * EvidenceDataUploadApi - axios parameter creator
 * @export
 */
export const EvidenceDataUploadApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Submit sign post evidence data
     * @param {SignPostEvidenceDto} signPostEvidenceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitEvidenceControllerSubmitSignPostEvidenceData: async (
      signPostEvidenceDto: SignPostEvidenceDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'signPostEvidenceDto' is not null or undefined
      assertParamExists(
        'iteraitEvidenceControllerSubmitSignPostEvidenceData',
        'signPostEvidenceDto',
        signPostEvidenceDto,
      )
      const localVarPath = `/sign-post-evidence-data`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        signPostEvidenceDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Submit vehicle evidence data
     * @param {VehicleEvidenceDto} vehicleEvidenceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitEvidenceControllerSubmitVehicleEvidenceData: async (
      vehicleEvidenceDto: VehicleEvidenceDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'vehicleEvidenceDto' is not null or undefined
      assertParamExists(
        'iteraitEvidenceControllerSubmitVehicleEvidenceData',
        'vehicleEvidenceDto',
        vehicleEvidenceDto,
      )
      const localVarPath = `/vehicle-evidence-data`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        vehicleEvidenceDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * EvidenceDataUploadApi - functional programming interface
 * @export
 */
export const EvidenceDataUploadApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EvidenceDataUploadApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Submit sign post evidence data
     * @param {SignPostEvidenceDto} signPostEvidenceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iteraitEvidenceControllerSubmitSignPostEvidenceData(
      signPostEvidenceDto: SignPostEvidenceDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iteraitEvidenceControllerSubmitSignPostEvidenceData(
          signPostEvidenceDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'EvidenceDataUploadApi.iteraitEvidenceControllerSubmitSignPostEvidenceData'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Submit vehicle evidence data
     * @param {VehicleEvidenceDto} vehicleEvidenceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iteraitEvidenceControllerSubmitVehicleEvidenceData(
      vehicleEvidenceDto: VehicleEvidenceDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iteraitEvidenceControllerSubmitVehicleEvidenceData(
          vehicleEvidenceDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'EvidenceDataUploadApi.iteraitEvidenceControllerSubmitVehicleEvidenceData'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * EvidenceDataUploadApi - factory interface
 * @export
 */
export const EvidenceDataUploadApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = EvidenceDataUploadApiFp(configuration)
  return {
    /**
     *
     * @summary Submit sign post evidence data
     * @param {SignPostEvidenceDto} signPostEvidenceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitEvidenceControllerSubmitSignPostEvidenceData(
      signPostEvidenceDto: SignPostEvidenceDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SuccessResponseDto> {
      return localVarFp
        .iteraitEvidenceControllerSubmitSignPostEvidenceData(signPostEvidenceDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Submit vehicle evidence data
     * @param {VehicleEvidenceDto} vehicleEvidenceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitEvidenceControllerSubmitVehicleEvidenceData(
      vehicleEvidenceDto: VehicleEvidenceDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SuccessResponseDto> {
      return localVarFp
        .iteraitEvidenceControllerSubmitVehicleEvidenceData(vehicleEvidenceDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * EvidenceDataUploadApi - object-oriented interface
 * @export
 * @class EvidenceDataUploadApi
 * @extends {BaseAPI}
 */
export class EvidenceDataUploadApi extends BaseAPI {
  /**
   *
   * @summary Submit sign post evidence data
   * @param {SignPostEvidenceDto} signPostEvidenceDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EvidenceDataUploadApi
   */
  public iteraitEvidenceControllerSubmitSignPostEvidenceData(
    signPostEvidenceDto: SignPostEvidenceDto,
    options?: RawAxiosRequestConfig,
  ) {
    return EvidenceDataUploadApiFp(this.configuration)
      .iteraitEvidenceControllerSubmitSignPostEvidenceData(signPostEvidenceDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Submit vehicle evidence data
   * @param {VehicleEvidenceDto} vehicleEvidenceDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EvidenceDataUploadApi
   */
  public iteraitEvidenceControllerSubmitVehicleEvidenceData(
    vehicleEvidenceDto: VehicleEvidenceDto,
    options?: RawAxiosRequestConfig,
  ) {
    return EvidenceDataUploadApiFp(this.configuration)
      .iteraitEvidenceControllerSubmitVehicleEvidenceData(vehicleEvidenceDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * IntrospectionApi - axios parameter creator
 * @export
 */
export const IntrospectionApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitIntrospectionControllerGetHealth: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/health`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get API version information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitIntrospectionControllerGetVersion: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/version`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * IntrospectionApi - functional programming interface
 * @export
 */
export const IntrospectionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = IntrospectionApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iteraitIntrospectionControllerGetHealth(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iteraitIntrospectionControllerGetHealth(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['IntrospectionApi.iteraitIntrospectionControllerGetHealth']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Get API version information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iteraitIntrospectionControllerGetVersion(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionResponse>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iteraitIntrospectionControllerGetVersion(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['IntrospectionApi.iteraitIntrospectionControllerGetVersion']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * IntrospectionApi - factory interface
 * @export
 */
export const IntrospectionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = IntrospectionApiFp(configuration)
  return {
    /**
     *
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitIntrospectionControllerGetHealth(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<HealthResponseDto> {
      return localVarFp
        .iteraitIntrospectionControllerGetHealth(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get API version information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitIntrospectionControllerGetVersion(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<VersionResponse> {
      return localVarFp
        .iteraitIntrospectionControllerGetVersion(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * IntrospectionApi - object-oriented interface
 * @export
 * @class IntrospectionApi
 * @extends {BaseAPI}
 */
export class IntrospectionApi extends BaseAPI {
  /**
   *
   * @summary Health check endpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IntrospectionApi
   */
  public iteraitIntrospectionControllerGetHealth(options?: RawAxiosRequestConfig) {
    return IntrospectionApiFp(this.configuration)
      .iteraitIntrospectionControllerGetHealth(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get API version information
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IntrospectionApi
   */
  public iteraitIntrospectionControllerGetVersion(options?: RawAxiosRequestConfig) {
    return IntrospectionApiFp(this.configuration)
      .iteraitIntrospectionControllerGetVersion(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * MobileAppApi - axios parameter creator
 * @export
 */
export const MobileAppApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get latest mobile app version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerGetMobileAppVersion: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/mobile/version`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get latest mobile app version
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    systemControllerGetMobileAppVersionOld: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/system/version`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update mobile app version
     * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerUpdateMobileAppVersion: async (
      mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'mobileAppVersionUpdateDto' is not null or undefined
      assertParamExists(
        'systemControllerUpdateMobileAppVersion',
        'mobileAppVersionUpdateDto',
        mobileAppVersionUpdateDto,
      )
      const localVarPath = `/mobile/version`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        mobileAppVersionUpdateDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update mobile app version
     * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    systemControllerUpdateMobileAppVersionOld: async (
      mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'mobileAppVersionUpdateDto' is not null or undefined
      assertParamExists(
        'systemControllerUpdateMobileAppVersionOld',
        'mobileAppVersionUpdateDto',
        mobileAppVersionUpdateDto,
      )
      const localVarPath = `/system/version`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        mobileAppVersionUpdateDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * MobileAppApi - functional programming interface
 * @export
 */
export const MobileAppApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MobileAppApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get latest mobile app version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async systemControllerGetMobileAppVersion(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.systemControllerGetMobileAppVersion(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['MobileAppApi.systemControllerGetMobileAppVersion']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Get latest mobile app version
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async systemControllerGetMobileAppVersionOld(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.systemControllerGetMobileAppVersionOld(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['MobileAppApi.systemControllerGetMobileAppVersionOld']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Update mobile app version
     * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async systemControllerUpdateMobileAppVersion(
      mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.systemControllerUpdateMobileAppVersion(
          mobileAppVersionUpdateDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['MobileAppApi.systemControllerUpdateMobileAppVersion']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Update mobile app version
     * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async systemControllerUpdateMobileAppVersionOld(
      mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.systemControllerUpdateMobileAppVersionOld(
          mobileAppVersionUpdateDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['MobileAppApi.systemControllerUpdateMobileAppVersionOld']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * MobileAppApi - factory interface
 * @export
 */
export const MobileAppApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = MobileAppApiFp(configuration)
  return {
    /**
     *
     * @summary Get latest mobile app version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerGetMobileAppVersion(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .systemControllerGetMobileAppVersion(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get latest mobile app version
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    systemControllerGetMobileAppVersionOld(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .systemControllerGetMobileAppVersionOld(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update mobile app version
     * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerUpdateMobileAppVersion(
      mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .systemControllerUpdateMobileAppVersion(mobileAppVersionUpdateDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update mobile app version
     * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    systemControllerUpdateMobileAppVersionOld(
      mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .systemControllerUpdateMobileAppVersionOld(mobileAppVersionUpdateDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * MobileAppApi - object-oriented interface
 * @export
 * @class MobileAppApi
 * @extends {BaseAPI}
 */
export class MobileAppApi extends BaseAPI {
  /**
   *
   * @summary Get latest mobile app version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MobileAppApi
   */
  public systemControllerGetMobileAppVersion(options?: RawAxiosRequestConfig) {
    return MobileAppApiFp(this.configuration)
      .systemControllerGetMobileAppVersion(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get latest mobile app version
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof MobileAppApi
   */
  public systemControllerGetMobileAppVersionOld(options?: RawAxiosRequestConfig) {
    return MobileAppApiFp(this.configuration)
      .systemControllerGetMobileAppVersionOld(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update mobile app version
   * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MobileAppApi
   */
  public systemControllerUpdateMobileAppVersion(
    mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
    options?: RawAxiosRequestConfig,
  ) {
    return MobileAppApiFp(this.configuration)
      .systemControllerUpdateMobileAppVersion(mobileAppVersionUpdateDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update mobile app version
   * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof MobileAppApi
   */
  public systemControllerUpdateMobileAppVersionOld(
    mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
    options?: RawAxiosRequestConfig,
  ) {
    return MobileAppApiFp(this.configuration)
      .systemControllerUpdateMobileAppVersionOld(mobileAppVersionUpdateDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ScansAndOffencesApi - axios parameter creator
 * @export
 */
export const ScansAndOffencesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create offence and send it to Enforcement backoffice.
     * @summary Create offence from scan.
     * @param {string} scanUuid
     * @param {string} data Stringified JSON of RequestCreateOffenceDataDto.
     * @param {Array<File>} files Array of jpeg files in base64 format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerCreateOffence: async (
      scanUuid: string,
      data: string,
      files: Array<File>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'scanUuid' is not null or undefined
      assertParamExists('scanControllerCreateOffence', 'scanUuid', scanUuid)
      // verify required parameter 'data' is not null or undefined
      assertParamExists('scanControllerCreateOffence', 'data', data)
      // verify required parameter 'files' is not null or undefined
      assertParamExists('scanControllerCreateOffence', 'files', files)
      const localVarPath = `/scan/offence/create/{scanUuid}`.replace(
        `{${'scanUuid'}}`,
        encodeURIComponent(String(scanUuid)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (data !== undefined) {
        localVarFormParams.append('data', data as any)
      }
      if (files) {
        files.forEach((element) => {
          localVarFormParams.append('files', element as any)
        })
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Creates scan and checks for potential offence duplicities and verifies if vehicle has valid parking ticket or residential card.
     * @summary Creates a new scan record for a vehicle.
     * @param {RequestCreateOrUpdateScanDto} requestCreateOrUpdateScanDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerCreateOrUpdateScanEcv: async (
      requestCreateOrUpdateScanDto: RequestCreateOrUpdateScanDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestCreateOrUpdateScanDto' is not null or undefined
      assertParamExists(
        'scanControllerCreateOrUpdateScanEcv',
        'requestCreateOrUpdateScanDto',
        requestCreateOrUpdateScanDto,
      )
      const localVarPath = `/scan/create-or-update`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestCreateOrUpdateScanDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Uploads a photo of a zone sign to S3 storage and saves its URL, user information, and optional tag in the database. Returns data about the saved image.
     * @summary Upload photo of zone sign.
     * @param {File} file Upload image
     * @param {string | null} [globalId] UUID of zone sign from GIS data.
     * @param {string | null} [tag] Arbitrary info about image, e.g. UDR number.
     * @param {number | null} [lat] Latitude of image.
     * @param {number | null} [_long] Longitude of image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerCreateZoneSignPhoto: async (
      file: File,
      globalId?: string | null,
      tag?: string | null,
      lat?: number | null,
      _long?: number | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists('scanControllerCreateZoneSignPhoto', 'file', file)
      const localVarPath = `/scan/zone-sign/create`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (globalId !== undefined) {
        localVarFormParams.append('globalId', globalId as any)
      }

      if (tag !== undefined) {
        localVarFormParams.append('tag', tag as any)
      }

      if (lat !== undefined) {
        localVarFormParams.append('lat', lat as any)
      }

      if (_long !== undefined) {
        localVarFormParams.append('long', _long as any)
      }

      if (file !== undefined) {
        localVarFormParams.append('file', file as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Search for offences based on provided parameters. This endpoint is typically used to detect potential duplicities within the last two weeks by supplying ECV and GPS coordinates.
     * @summary Find offences matching given filters
     * @param {string} ecv Vehicle license plate.
     * @param {Array<ScanControllerGetOffenceListOffenceTypesEnum>} [offenceTypes] PAAS offence types include N, N_B, O, DZ, and ZIGZAG. All other types are considered municipal police (OTHER) offence types.
     * @param {string | null} [udr] UDR code (4-digit number or \&quot;0\&quot;) for the offence location.
     * @param {number} [lat] Latitude used to filter offences by proximity. If provided, only offences near this location are returned.
     * @param {number} [_long] Longitude used to filter offences by proximity. If provided, only offences near this location are returned.
     * @param {string} [startDate] Start date of the filter interval. Only offences created after this date will be included.
     * @param {string} [endDate] End date of the filter interval. Only offences created before this date will be included.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerGetOffenceList: async (
      ecv: string,
      offenceTypes?: Array<ScanControllerGetOffenceListOffenceTypesEnum>,
      udr?: string | null,
      lat?: number,
      _long?: number,
      startDate?: string,
      endDate?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ecv' is not null or undefined
      assertParamExists('scanControllerGetOffenceList', 'ecv', ecv)
      const localVarPath = `/scan/offences`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (offenceTypes) {
        localVarQueryParameter['offenceTypes'] = offenceTypes
      }

      if (ecv !== undefined) {
        localVarQueryParameter['ecv'] = ecv
      }

      if (udr !== undefined) {
        localVarQueryParameter['udr'] = udr
      }

      if (lat !== undefined) {
        localVarQueryParameter['lat'] = lat
      }

      if (_long !== undefined) {
        localVarQueryParameter['long'] = _long
      }

      if (startDate !== undefined) {
        localVarQueryParameter['startDate'] = startDate
      }

      if (endDate !== undefined) {
        localVarQueryParameter['endDate'] = endDate
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns vehicle details for the specified ECV as registered in the state registry. If multiple vehicles are found for the same license plate, all are returned. This endpoint is useful for verifying vehicle information during scanning.
     * @summary Retrieve basic vehicle properties from the state registry by license plate.
     * @param {string} ecv Vehicle license plate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerGetVehicleProperties: async (
      ecv: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ecv' is not null or undefined
      assertParamExists('scanControllerGetVehicleProperties', 'ecv', ecv)
      const localVarPath = `/scan/vehicle-properties/{ecv}`.replace(
        `{${'ecv'}}`,
        encodeURIComponent(String(ecv)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns all zone sign photos uploaded today by the authenticated user. Each photo includes its URL, ID, and tag. This endpoint helps users quickly access their recently uploaded zone sign photos.
     * @summary Get zone sign photos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerGetZoneSignPhotos: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/scan/zone-sign/photos`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a list of offences created by the authenticated user, filtered by ECV and time. By default, it selects all offences from the last 10 hours for all ECVs. This endpoint helps users quickly review their recent enforcement activity.
     * @summary Get recent offences of logged user
     * @param {string} [date] Start date of the filter interval. Only offences created after this date will be included.
     * @param {string} [ecv] Vehicle license plate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerOffenceOverview: async (
      date?: string,
      ecv?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/scan/offence-overview`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (date !== undefined) {
        localVarQueryParameter['date'] = date
      }

      if (ecv !== undefined) {
        localVarQueryParameter['ecv'] = ecv
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns all parking tickets and permit cards for the specified ECV and date (all day). The response includes a flag indicating whether particular ticket was valid on the requested date. Default, today.
     * @summary Get active tickets and permit cards of vehicle
     * @param {string} ecv Vehicle license plate.
     * @param {string} [date] All parking tickets and cards which were active on this day will be returned. Validity of each ticket will be checked against exact time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerTicketsAndPermits: async (
      ecv: string,
      date?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ecv' is not null or undefined
      assertParamExists('scanControllerTicketsAndPermits', 'ecv', ecv)
      const localVarPath = `/scan/tickets-and-permits`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (ecv !== undefined) {
        localVarQueryParameter['ecv'] = ecv
      }

      if (date !== undefined) {
        localVarQueryParameter['date'] =
          (date as any) instanceof Date ? (date as any).toISOString() : date
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ScansAndOffencesApi - functional programming interface
 * @export
 */
export const ScansAndOffencesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ScansAndOffencesApiAxiosParamCreator(configuration)
  return {
    /**
     * Create offence and send it to Enforcement backoffice.
     * @summary Create offence from scan.
     * @param {string} scanUuid
     * @param {string} data Stringified JSON of RequestCreateOffenceDataDto.
     * @param {Array<File>} files Array of jpeg files in base64 format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scanControllerCreateOffence(
      scanUuid: string,
      data: string,
      files: Array<File>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreateOffenceDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scanControllerCreateOffence(
        scanUuid,
        data,
        files,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScansAndOffencesApi.scanControllerCreateOffence']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Creates scan and checks for potential offence duplicities and verifies if vehicle has valid parking ticket or residential card.
     * @summary Creates a new scan record for a vehicle.
     * @param {RequestCreateOrUpdateScanDto} requestCreateOrUpdateScanDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scanControllerCreateOrUpdateScanEcv(
      requestCreateOrUpdateScanDto: RequestCreateOrUpdateScanDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreateOrUpdateScanDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scanControllerCreateOrUpdateScanEcv(
        requestCreateOrUpdateScanDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScansAndOffencesApi.scanControllerCreateOrUpdateScanEcv']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Uploads a photo of a zone sign to S3 storage and saves its URL, user information, and optional tag in the database. Returns data about the saved image.
     * @summary Upload photo of zone sign.
     * @param {File} file Upload image
     * @param {string | null} [globalId] UUID of zone sign from GIS data.
     * @param {string | null} [tag] Arbitrary info about image, e.g. UDR number.
     * @param {number | null} [lat] Latitude of image.
     * @param {number | null} [_long] Longitude of image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scanControllerCreateZoneSignPhoto(
      file: File,
      globalId?: string | null,
      tag?: string | null,
      lat?: number | null,
      _long?: number | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseZoneSignPhotoPropertiesDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scanControllerCreateZoneSignPhoto(
        file,
        globalId,
        tag,
        lat,
        _long,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScansAndOffencesApi.scanControllerCreateZoneSignPhoto']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Search for offences based on provided parameters. This endpoint is typically used to detect potential duplicities within the last two weeks by supplying ECV and GPS coordinates.
     * @summary Find offences matching given filters
     * @param {string} ecv Vehicle license plate.
     * @param {Array<ScanControllerGetOffenceListOffenceTypesEnum>} [offenceTypes] PAAS offence types include N, N_B, O, DZ, and ZIGZAG. All other types are considered municipal police (OTHER) offence types.
     * @param {string | null} [udr] UDR code (4-digit number or \&quot;0\&quot;) for the offence location.
     * @param {number} [lat] Latitude used to filter offences by proximity. If provided, only offences near this location are returned.
     * @param {number} [_long] Longitude used to filter offences by proximity. If provided, only offences near this location are returned.
     * @param {string} [startDate] Start date of the filter interval. Only offences created after this date will be included.
     * @param {string} [endDate] End date of the filter interval. Only offences created before this date will be included.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scanControllerGetOffenceList(
      ecv: string,
      offenceTypes?: Array<ScanControllerGetOffenceListOffenceTypesEnum>,
      udr?: string | null,
      lat?: number,
      _long?: number,
      startDate?: string,
      endDate?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseBaseOffenceDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scanControllerGetOffenceList(
        ecv,
        offenceTypes,
        udr,
        lat,
        _long,
        startDate,
        endDate,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScansAndOffencesApi.scanControllerGetOffenceList']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Returns vehicle details for the specified ECV as registered in the state registry. If multiple vehicles are found for the same license plate, all are returned. This endpoint is useful for verifying vehicle information during scanning.
     * @summary Retrieve basic vehicle properties from the state registry by license plate.
     * @param {string} ecv Vehicle license plate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scanControllerGetVehicleProperties(
      ecv: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseVehiclePropertiesDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scanControllerGetVehicleProperties(
        ecv,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScansAndOffencesApi.scanControllerGetVehicleProperties']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Returns all zone sign photos uploaded today by the authenticated user. Each photo includes its URL, ID, and tag. This endpoint helps users quickly access their recently uploaded zone sign photos.
     * @summary Get zone sign photos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scanControllerGetZoneSignPhotos(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetZoneSignPhotosDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.scanControllerGetZoneSignPhotos(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScansAndOffencesApi.scanControllerGetZoneSignPhotos']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Returns a list of offences created by the authenticated user, filtered by ECV and time. By default, it selects all offences from the last 10 hours for all ECVs. This endpoint helps users quickly review their recent enforcement activity.
     * @summary Get recent offences of logged user
     * @param {string} [date] Start date of the filter interval. Only offences created after this date will be included.
     * @param {string} [ecv] Vehicle license plate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scanControllerOffenceOverview(
      date?: string,
      ecv?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetOffenceOverviewListDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scanControllerOffenceOverview(
        date,
        ecv,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScansAndOffencesApi.scanControllerOffenceOverview']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Returns all parking tickets and permit cards for the specified ECV and date (all day). The response includes a flag indicating whether particular ticket was valid on the requested date. Default, today.
     * @summary Get active tickets and permit cards of vehicle
     * @param {string} ecv Vehicle license plate.
     * @param {string} [date] All parking tickets and cards which were active on this day will be returned. Validity of each ticket will be checked against exact time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scanControllerTicketsAndPermits(
      ecv: string,
      date?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseTicketsAndPermitsDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scanControllerTicketsAndPermits(
        ecv,
        date,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScansAndOffencesApi.scanControllerTicketsAndPermits']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ScansAndOffencesApi - factory interface
 * @export
 */
export const ScansAndOffencesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ScansAndOffencesApiFp(configuration)
  return {
    /**
     * Create offence and send it to Enforcement backoffice.
     * @summary Create offence from scan.
     * @param {string} scanUuid
     * @param {string} data Stringified JSON of RequestCreateOffenceDataDto.
     * @param {Array<File>} files Array of jpeg files in base64 format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerCreateOffence(
      scanUuid: string,
      data: string,
      files: Array<File>,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseCreateOffenceDto> {
      return localVarFp
        .scanControllerCreateOffence(scanUuid, data, files, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Creates scan and checks for potential offence duplicities and verifies if vehicle has valid parking ticket or residential card.
     * @summary Creates a new scan record for a vehicle.
     * @param {RequestCreateOrUpdateScanDto} requestCreateOrUpdateScanDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerCreateOrUpdateScanEcv(
      requestCreateOrUpdateScanDto: RequestCreateOrUpdateScanDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseCreateOrUpdateScanDto> {
      return localVarFp
        .scanControllerCreateOrUpdateScanEcv(requestCreateOrUpdateScanDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Uploads a photo of a zone sign to S3 storage and saves its URL, user information, and optional tag in the database. Returns data about the saved image.
     * @summary Upload photo of zone sign.
     * @param {File} file Upload image
     * @param {string | null} [globalId] UUID of zone sign from GIS data.
     * @param {string | null} [tag] Arbitrary info about image, e.g. UDR number.
     * @param {number | null} [lat] Latitude of image.
     * @param {number | null} [_long] Longitude of image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerCreateZoneSignPhoto(
      file: File,
      globalId?: string | null,
      tag?: string | null,
      lat?: number | null,
      _long?: number | null,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseZoneSignPhotoPropertiesDto> {
      return localVarFp
        .scanControllerCreateZoneSignPhoto(file, globalId, tag, lat, _long, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Search for offences based on provided parameters. This endpoint is typically used to detect potential duplicities within the last two weeks by supplying ECV and GPS coordinates.
     * @summary Find offences matching given filters
     * @param {string} ecv Vehicle license plate.
     * @param {Array<ScanControllerGetOffenceListOffenceTypesEnum>} [offenceTypes] PAAS offence types include N, N_B, O, DZ, and ZIGZAG. All other types are considered municipal police (OTHER) offence types.
     * @param {string | null} [udr] UDR code (4-digit number or \&quot;0\&quot;) for the offence location.
     * @param {number} [lat] Latitude used to filter offences by proximity. If provided, only offences near this location are returned.
     * @param {number} [_long] Longitude used to filter offences by proximity. If provided, only offences near this location are returned.
     * @param {string} [startDate] Start date of the filter interval. Only offences created after this date will be included.
     * @param {string} [endDate] End date of the filter interval. Only offences created before this date will be included.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerGetOffenceList(
      ecv: string,
      offenceTypes?: Array<ScanControllerGetOffenceListOffenceTypesEnum>,
      udr?: string | null,
      lat?: number,
      _long?: number,
      startDate?: string,
      endDate?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ResponseBaseOffenceDto>> {
      return localVarFp
        .scanControllerGetOffenceList(
          ecv,
          offenceTypes,
          udr,
          lat,
          _long,
          startDate,
          endDate,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns vehicle details for the specified ECV as registered in the state registry. If multiple vehicles are found for the same license plate, all are returned. This endpoint is useful for verifying vehicle information during scanning.
     * @summary Retrieve basic vehicle properties from the state registry by license plate.
     * @param {string} ecv Vehicle license plate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerGetVehicleProperties(
      ecv: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseVehiclePropertiesDto> {
      return localVarFp
        .scanControllerGetVehicleProperties(ecv, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns all zone sign photos uploaded today by the authenticated user. Each photo includes its URL, ID, and tag. This endpoint helps users quickly access their recently uploaded zone sign photos.
     * @summary Get zone sign photos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerGetZoneSignPhotos(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseGetZoneSignPhotosDto> {
      return localVarFp
        .scanControllerGetZoneSignPhotos(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a list of offences created by the authenticated user, filtered by ECV and time. By default, it selects all offences from the last 10 hours for all ECVs. This endpoint helps users quickly review their recent enforcement activity.
     * @summary Get recent offences of logged user
     * @param {string} [date] Start date of the filter interval. Only offences created after this date will be included.
     * @param {string} [ecv] Vehicle license plate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerOffenceOverview(
      date?: string,
      ecv?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseGetOffenceOverviewListDto> {
      return localVarFp
        .scanControllerOffenceOverview(date, ecv, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns all parking tickets and permit cards for the specified ECV and date (all day). The response includes a flag indicating whether particular ticket was valid on the requested date. Default, today.
     * @summary Get active tickets and permit cards of vehicle
     * @param {string} ecv Vehicle license plate.
     * @param {string} [date] All parking tickets and cards which were active on this day will be returned. Validity of each ticket will be checked against exact time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerTicketsAndPermits(
      ecv: string,
      date?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseTicketsAndPermitsDto> {
      return localVarFp
        .scanControllerTicketsAndPermits(ecv, date, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ScansAndOffencesApi - object-oriented interface
 * @export
 * @class ScansAndOffencesApi
 * @extends {BaseAPI}
 */
export class ScansAndOffencesApi extends BaseAPI {
  /**
   * Create offence and send it to Enforcement backoffice.
   * @summary Create offence from scan.
   * @param {string} scanUuid
   * @param {string} data Stringified JSON of RequestCreateOffenceDataDto.
   * @param {Array<File>} files Array of jpeg files in base64 format.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScansAndOffencesApi
   */
  public scanControllerCreateOffence(
    scanUuid: string,
    data: string,
    files: Array<File>,
    options?: RawAxiosRequestConfig,
  ) {
    return ScansAndOffencesApiFp(this.configuration)
      .scanControllerCreateOffence(scanUuid, data, files, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Creates scan and checks for potential offence duplicities and verifies if vehicle has valid parking ticket or residential card.
   * @summary Creates a new scan record for a vehicle.
   * @param {RequestCreateOrUpdateScanDto} requestCreateOrUpdateScanDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScansAndOffencesApi
   */
  public scanControllerCreateOrUpdateScanEcv(
    requestCreateOrUpdateScanDto: RequestCreateOrUpdateScanDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ScansAndOffencesApiFp(this.configuration)
      .scanControllerCreateOrUpdateScanEcv(requestCreateOrUpdateScanDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Uploads a photo of a zone sign to S3 storage and saves its URL, user information, and optional tag in the database. Returns data about the saved image.
   * @summary Upload photo of zone sign.
   * @param {File} file Upload image
   * @param {string | null} [globalId] UUID of zone sign from GIS data.
   * @param {string | null} [tag] Arbitrary info about image, e.g. UDR number.
   * @param {number | null} [lat] Latitude of image.
   * @param {number | null} [_long] Longitude of image.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScansAndOffencesApi
   */
  public scanControllerCreateZoneSignPhoto(
    file: File,
    globalId?: string | null,
    tag?: string | null,
    lat?: number | null,
    _long?: number | null,
    options?: RawAxiosRequestConfig,
  ) {
    return ScansAndOffencesApiFp(this.configuration)
      .scanControllerCreateZoneSignPhoto(file, globalId, tag, lat, _long, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Search for offences based on provided parameters. This endpoint is typically used to detect potential duplicities within the last two weeks by supplying ECV and GPS coordinates.
   * @summary Find offences matching given filters
   * @param {string} ecv Vehicle license plate.
   * @param {Array<ScanControllerGetOffenceListOffenceTypesEnum>} [offenceTypes] PAAS offence types include N, N_B, O, DZ, and ZIGZAG. All other types are considered municipal police (OTHER) offence types.
   * @param {string | null} [udr] UDR code (4-digit number or \&quot;0\&quot;) for the offence location.
   * @param {number} [lat] Latitude used to filter offences by proximity. If provided, only offences near this location are returned.
   * @param {number} [_long] Longitude used to filter offences by proximity. If provided, only offences near this location are returned.
   * @param {string} [startDate] Start date of the filter interval. Only offences created after this date will be included.
   * @param {string} [endDate] End date of the filter interval. Only offences created before this date will be included.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScansAndOffencesApi
   */
  public scanControllerGetOffenceList(
    ecv: string,
    offenceTypes?: Array<ScanControllerGetOffenceListOffenceTypesEnum>,
    udr?: string | null,
    lat?: number,
    _long?: number,
    startDate?: string,
    endDate?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ScansAndOffencesApiFp(this.configuration)
      .scanControllerGetOffenceList(ecv, offenceTypes, udr, lat, _long, startDate, endDate, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns vehicle details for the specified ECV as registered in the state registry. If multiple vehicles are found for the same license plate, all are returned. This endpoint is useful for verifying vehicle information during scanning.
   * @summary Retrieve basic vehicle properties from the state registry by license plate.
   * @param {string} ecv Vehicle license plate.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScansAndOffencesApi
   */
  public scanControllerGetVehicleProperties(ecv: string, options?: RawAxiosRequestConfig) {
    return ScansAndOffencesApiFp(this.configuration)
      .scanControllerGetVehicleProperties(ecv, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns all zone sign photos uploaded today by the authenticated user. Each photo includes its URL, ID, and tag. This endpoint helps users quickly access their recently uploaded zone sign photos.
   * @summary Get zone sign photos
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScansAndOffencesApi
   */
  public scanControllerGetZoneSignPhotos(options?: RawAxiosRequestConfig) {
    return ScansAndOffencesApiFp(this.configuration)
      .scanControllerGetZoneSignPhotos(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a list of offences created by the authenticated user, filtered by ECV and time. By default, it selects all offences from the last 10 hours for all ECVs. This endpoint helps users quickly review their recent enforcement activity.
   * @summary Get recent offences of logged user
   * @param {string} [date] Start date of the filter interval. Only offences created after this date will be included.
   * @param {string} [ecv] Vehicle license plate.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScansAndOffencesApi
   */
  public scanControllerOffenceOverview(
    date?: string,
    ecv?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ScansAndOffencesApiFp(this.configuration)
      .scanControllerOffenceOverview(date, ecv, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns all parking tickets and permit cards for the specified ECV and date (all day). The response includes a flag indicating whether particular ticket was valid on the requested date. Default, today.
   * @summary Get active tickets and permit cards of vehicle
   * @param {string} ecv Vehicle license plate.
   * @param {string} [date] All parking tickets and cards which were active on this day will be returned. Validity of each ticket will be checked against exact time.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScansAndOffencesApi
   */
  public scanControllerTicketsAndPermits(
    ecv: string,
    date?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ScansAndOffencesApiFp(this.configuration)
      .scanControllerTicketsAndPermits(ecv, date, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const ScanControllerGetOffenceListOffenceTypesEnum = {
  A: 'A',
  B: 'B',
  C: 'C',
  D: 'D',
  E: 'E',
  F: 'F',
  G: 'G',
  H: 'H',
  I: 'I',
  J: 'J',
  K: 'K',
  L: 'L',
  M: 'M',
  N: 'N',
  O: 'O',
  P: 'P',
  Q: 'Q',
  R: 'R',
  S: 'S',
  T: 'T',
  U: 'U',
  Dz: 'DZ',
  NB: 'N_B',
  Zigzag: 'ZIGZAG',
} as const
export type ScanControllerGetOffenceListOffenceTypesEnum =
  (typeof ScanControllerGetOffenceListOffenceTypesEnum)[keyof typeof ScanControllerGetOffenceListOffenceTypesEnum]

/**
 * ShiftsApi - axios parameter creator
 * @export
 */
export const ShiftsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Submit driver shift end event
     * @param {RideEventDto} rideEventDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitShiftControllerSubmitDriverShiftEnd: async (
      rideEventDto: RideEventDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'rideEventDto' is not null or undefined
      assertParamExists('iteraitShiftControllerSubmitDriverShiftEnd', 'rideEventDto', rideEventDto)
      const localVarPath = `/driver-shift-end`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        rideEventDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Submit driver shift start event
     * @param {RideEventDto} rideEventDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitShiftControllerSubmitDriverShiftStart: async (
      rideEventDto: RideEventDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'rideEventDto' is not null or undefined
      assertParamExists(
        'iteraitShiftControllerSubmitDriverShiftStart',
        'rideEventDto',
        rideEventDto,
      )
      const localVarPath = `/driver-shift-start`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        rideEventDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ShiftsApi - functional programming interface
 * @export
 */
export const ShiftsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ShiftsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Submit driver shift end event
     * @param {RideEventDto} rideEventDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iteraitShiftControllerSubmitDriverShiftEnd(
      rideEventDto: RideEventDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iteraitShiftControllerSubmitDriverShiftEnd(
          rideEventDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ShiftsApi.iteraitShiftControllerSubmitDriverShiftEnd']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Submit driver shift start event
     * @param {RideEventDto} rideEventDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iteraitShiftControllerSubmitDriverShiftStart(
      rideEventDto: RideEventDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iteraitShiftControllerSubmitDriverShiftStart(
          rideEventDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ShiftsApi.iteraitShiftControllerSubmitDriverShiftStart']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ShiftsApi - factory interface
 * @export
 */
export const ShiftsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ShiftsApiFp(configuration)
  return {
    /**
     *
     * @summary Submit driver shift end event
     * @param {RideEventDto} rideEventDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitShiftControllerSubmitDriverShiftEnd(
      rideEventDto: RideEventDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SuccessResponseDto> {
      return localVarFp
        .iteraitShiftControllerSubmitDriverShiftEnd(rideEventDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Submit driver shift start event
     * @param {RideEventDto} rideEventDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iteraitShiftControllerSubmitDriverShiftStart(
      rideEventDto: RideEventDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SuccessResponseDto> {
      return localVarFp
        .iteraitShiftControllerSubmitDriverShiftStart(rideEventDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ShiftsApi - object-oriented interface
 * @export
 * @class ShiftsApi
 * @extends {BaseAPI}
 */
export class ShiftsApi extends BaseAPI {
  /**
   *
   * @summary Submit driver shift end event
   * @param {RideEventDto} rideEventDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ShiftsApi
   */
  public iteraitShiftControllerSubmitDriverShiftEnd(
    rideEventDto: RideEventDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ShiftsApiFp(this.configuration)
      .iteraitShiftControllerSubmitDriverShiftEnd(rideEventDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Submit driver shift start event
   * @param {RideEventDto} rideEventDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ShiftsApi
   */
  public iteraitShiftControllerSubmitDriverShiftStart(
    rideEventDto: RideEventDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ShiftsApiFp(this.configuration)
      .iteraitShiftControllerSubmitDriverShiftStart(rideEventDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
