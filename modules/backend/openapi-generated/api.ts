/* tslint:disable */
/* eslint-disable */
/**
 * Bratislava Enforcement scan app backend
 * Enforcement backend for mobile app for lustrating and creating penalties for bad parking and traffic violations
 *
 * The version of the OpenAPI document: 1.0
 * Contact: inovacie@bratislava.sk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig, AxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setBearerAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, BaseAPI, RequiredError, operationServerMap } from './base'

/**
 *
 * @export
 * @interface CustomErrorDependencyDto
 */
export interface CustomErrorDependencyDto {
  /**
   * Status Code
   * @type {number}
   * @memberof CustomErrorDependencyDto
   */
  statusCode: number
  /**
   * status in text
   * @type {string}
   * @memberof CustomErrorDependencyDto
   */
  status: string
  /**
   * Detail error message
   * @type {string}
   * @memberof CustomErrorDependencyDto
   */
  message: string
  /**
   *
   * @type {CustomErrorsDependencyEnum}
   * @memberof CustomErrorDependencyDto
   */
  errorName: CustomErrorsDependencyEnum
  /**
   * Helper for sending additional data in error
   * @type {string}
   * @memberof CustomErrorDependencyDto
   */
  msg?: string
}

/**
 * Exact error name
 * @export
 * @enum {string}
 */

export const CustomErrorsDependencyEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
  NUMBER_3: 3,
  NUMBER_4: 4,
  NUMBER_5: 5,
  NUMBER_6: 6,
  NUMBER_7: 7,
} as const

export type CustomErrorsDependencyEnum =
  (typeof CustomErrorsDependencyEnum)[keyof typeof CustomErrorsDependencyEnum]

/**
 *
 * @export
 * @interface DefaultResponseHealthcheck
 */
export interface DefaultResponseHealthcheck {
  /**
   * is application it running?
   * @type {boolean}
   * @memberof DefaultResponseHealthcheck
   */
  appRunning: boolean
}
/**
 *
 * @export
 * @interface MobileAppVersionUpdateDto
 */
export interface MobileAppVersionUpdateDto {
  /**
   * Version required from the user
   * @type {string}
   * @memberof MobileAppVersionUpdateDto
   */
  version: string
}
/**
 * State of offence
 * @export
 * @enum {string}
 */

export const OffenceStateEnum = {
  Created: 'CREATED',
  Updated: 'UPDATED',
  Registered: 'REGISTERED',
  NotOffence: 'NOT_OFFENCE',
  BackofficeError: 'BACKOFFICE_ERROR',
} as const

export type OffenceStateEnum = (typeof OffenceStateEnum)[keyof typeof OffenceStateEnum]

/**
 * Type of offence by legislation
 * @export
 * @enum {string}
 */

export const OffenceTypeEnum = {
  A: 'A',
  B: 'B',
  C: 'C',
  D: 'D',
  E: 'E',
  F: 'F',
  G: 'G',
  H: 'H',
  I: 'I',
  J: 'J',
  K: 'K',
  L: 'L',
  M: 'M',
  N: 'N',
  O: 'O',
  P: 'P',
  Q: 'Q',
  R: 'R',
  S: 'S',
  T: 'T',
  U: 'U',
  Dz: 'DZ',
  NB: 'N_B',
} as const

export type OffenceTypeEnum = (typeof OffenceTypeEnum)[keyof typeof OffenceTypeEnum]

/**
 *
 * @export
 * @interface RequestCreateOffenceDataDto
 */
export interface RequestCreateOffenceDataDto {
  /**
   *
   * @type {OffenceTypeEnum}
   * @memberof RequestCreateOffenceDataDto
   */
  offenceType: OffenceTypeEnum
  /**
   * Is it objective responsibility(true) or it is subjective(false)?
   * @type {boolean}
   * @memberof RequestCreateOffenceDataDto
   */
  objectiveResponsibility: boolean
  /**
   * Longitude of scan place if is changed in map
   * @type {string}
   * @memberof RequestCreateOffenceDataDto
   */
  long?: string
  /**
   * Latitude of scan place if is changed in map
   * @type {string}
   * @memberof RequestCreateOffenceDataDto
   */
  lat?: string
  /**
   * Name of street if is changed in map
   * @type {string}
   * @memberof RequestCreateOffenceDataDto
   */
  streetName?: string
  /**
   * Udr if is changed in map
   * @type {string}
   * @memberof RequestCreateOffenceDataDto
   */
  udr?: string
  /**
   * Vehicle id, helps to identify vehicle in case of more than 1 item per ecv
   * @type {number}
   * @memberof RequestCreateOffenceDataDto
   */
  vehicleId?: number
  /**
   *
   * @type {ResolutionOffenceTypeEnum}
   * @memberof RequestCreateOffenceDataDto
   */
  resolutionType?: ResolutionOffenceTypeEnum
  /**
   * Id of zone photo stored in favourite photos
   * @type {number}
   * @memberof RequestCreateOffenceDataDto
   */
  favouritePhotoId?: number
  /**
   * Current version of mobile app version
   * @type {string}
   * @memberof RequestCreateOffenceDataDto
   */
  mobileAppVersion?: string
}

/**
 *
 * @export
 * @interface RequestCreateOrUpdateScanDto
 */
export interface RequestCreateOrUpdateScanDto {
  /**
   * Uuid of scan if you want to update, if this is not set, than it will create new scan.
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  uuid?: string
  /**
   * Scanned ecv
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  ecv: string
  /**
   * Longitude of scan place
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  long: string
  /**
   * Latitude of scan place
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  lat: string
  /**
   * Is it manually written? if false it is from scanner ECV, if true, it is changed / added manually
   * @type {boolean}
   * @memberof RequestCreateOrUpdateScanDto
   */
  ecvUpdatedManually: boolean
  /**
   *
   * @type {ScanReasonEnum}
   * @memberof RequestCreateOrUpdateScanDto
   */
  scanReason: ScanReasonEnum
  /**
   * For now, send udr code, but this will be redefined by parkdots endpoints
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  udr?: string
  /**
   * Street Name from map or gps TBD if this is necessary
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  streetName?: string
  /**
   *
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  district?: string
  /**
   *
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  areaName?: string
  /**
   * Code of area
   * @type {Array<string>}
   * @memberof RequestCreateOrUpdateScanDto
   */
  areaCodes?: Array<string> | null
  /**
   * Uuid of udr, generated from gis, used for paas parking authorization - part of request to Parkdots
   * @type {string}
   * @memberof RequestCreateOrUpdateScanDto
   */
  udrGlobalId?: string | null
}

/**
 * Type of resolution in case of subjective responsibility
 * @export
 * @enum {string}
 */

export const ResolutionOffenceTypeEnum = {
  JustRegistration: 'JUST_REGISTRATION',
  UnjustifiedReport: 'UNJUSTIFIED_REPORT',
  NotCaught: 'NOT_CAUGHT',
  BlockingDevice: 'BLOCKING_DEVICE',
  Fine: 'FINE',
  SewedUp: 'SEWED_UP',
  Notification: 'NOTIFICATION',
  ForwardedToDi: 'FORWARDED_TO_DI',
} as const

export type ResolutionOffenceTypeEnum =
  (typeof ResolutionOffenceTypeEnum)[keyof typeof ResolutionOffenceTypeEnum]

/**
 *
 * @export
 * @interface ResponseCreateOffenceDto
 */
export interface ResponseCreateOffenceDto {
  /**
   * Id of scan if you want to update, if this is not set, than it will create new scan.
   * @type {number}
   * @memberof ResponseCreateOffenceDto
   */
  id: number
  /**
   * Uuid of scan if you want to update, if this is not set, than it will create new scan.
   * @type {string}
   * @memberof ResponseCreateOffenceDto
   */
  uuid: string
  /**
   * Timestamp of creation in UTC
   * @type {string}
   * @memberof ResponseCreateOffenceDto
   */
  createdAt: string
  /**
   * Timestamp of last update in UTC
   * @type {string}
   * @memberof ResponseCreateOffenceDto
   */
  updatedAt: string
  /**
   * Id of user from AD, who created this scan
   * @type {string}
   * @memberof ResponseCreateOffenceDto
   */
  createdBy: string
  /**
   * Id of user from AD, who last updated this scan
   * @type {string}
   * @memberof ResponseCreateOffenceDto
   */
  updatedBy: string
  /**
   * Email of user from AD, who created this scan
   * @type {string}
   * @memberof ResponseCreateOffenceDto
   */
  createdByEmail: string
  /**
   * Email of user from AD, who last updated this scan
   * @type {string}
   * @memberof ResponseCreateOffenceDto
   */
  updatedByEmail: string
  /**
   *
   * @type {OffenceTypeEnum}
   * @memberof ResponseCreateOffenceDto
   */
  offenceType: OffenceTypeEnum
  /**
   *
   * @type {OffenceStateEnum}
   * @memberof ResponseCreateOffenceDto
   */
  offenceState: OffenceStateEnum
  /**
   * Id of scan of vehicle from which is this offence
   * @type {number}
   * @memberof ResponseCreateOffenceDto
   */
  scanVehicleId: number
  /**
   * Id of vehicle, may be used to identify vehicle in case of multiple items per ecv
   * @type {string}
   * @memberof ResponseCreateOffenceDto
   */
  registryVehicleId?: string | null
  /**
   * Reference in db
   * @type {number}
   * @memberof ResponseCreateOffenceDto
   */
  favouritePhotoId?: number | null
  /**
   *
   * @type {boolean}
   * @memberof ResponseCreateOffenceDto
   */
  objectiveResponsibility: boolean
}

/**
 *
 * @export
 * @interface ResponseCreateOrUpdateScanDto
 */
export interface ResponseCreateOrUpdateScanDto {
  /**
   * Id of scan if you want to update, if this is not set, than it will create new scan.
   * @type {number}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  id: number
  /**
   * Uuid of scan if you want to update, if this is not set, than it will create new scan.
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  uuid: string
  /**
   * Timestamp of creation in UTC
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  createdAt: string
  /**
   * Timestamp of last update in UTC
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  updatedAt: string
  /**
   * System where scan was created
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  createdBy: string
  /**
   * System where scan was updated
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  updatedBy: string
  /**
   * Email of user from AD, who created this scan
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  createdByEmail: string
  /**
   * Email of user from AD, who last updated this scan
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  updatedByEmail: string
  /**
   * Longitude of last scan or manually updated from pin from map
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  long: string
  /**
   * Latitude of last scan or manually updated from pin from map
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  lat: string
  /**
   * Udr ID if it is paas scan
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  udr?: string | null
  /**
   * Ecv from scan, it is last updated ecv, it is possible that is updated also manually or last scanned
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  ecv: string
  /**
   * First scanned ecv or manually added
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  firstScannedEcv: string
  /**
   * Number of tries of scans
   * @type {number}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  numberOfScans: number
  /**
   * Was Ecv updated manually?
   * @type {boolean}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  ecvUpdatedManually: boolean
  /**
   *
   * @type {ScanReasonEnum}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  scanReason: ScanReasonEnum
  /**
   * Is Archived?
   * @type {boolean}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  archived: boolean
  /**
   * Street of offence by gps from map
   * @type {string}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  streetName?: string | null
  /**
   *
   * @type {ScanResultEnum}
   * @memberof ResponseCreateOrUpdateScanDto
   */
  scanResult?: ScanResultEnum
}

/**
 *
 * @export
 * @interface ResponseGetFavouritePhotoDto
 */
export interface ResponseGetFavouritePhotoDto {
  /**
   *
   * @type {string}
   * @memberof ResponseGetFavouritePhotoDto
   */
  photoUrl: string
  /**
   *
   * @type {number}
   * @memberof ResponseGetFavouritePhotoDto
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof ResponseGetFavouritePhotoDto
   */
  tag?: string | null
}
/**
 *
 * @export
 * @interface ResponseGetFavouritePhotosDto
 */
export interface ResponseGetFavouritePhotosDto {
  /**
   *
   * @type {Array<ResponseGetFavouritePhotoDto>}
   * @memberof ResponseGetFavouritePhotosDto
   */
  photos: Array<ResponseGetFavouritePhotoDto>
}
/**
 *
 * @export
 * @interface ResponseVehiclePropertiesDto
 */
export interface ResponseVehiclePropertiesDto {
  /**
   * List of vehicles for one licence plate, there can be two same licence plate with different vehicle type. User can use which is scanned and send vehicleId to offence response.
   * @type {Array<ResponseVehiclePropertiesItemDto>}
   * @memberof ResponseVehiclePropertiesDto
   */
  items: Array<ResponseVehiclePropertiesItemDto>
}
/**
 *
 * @export
 * @interface ResponseVehiclePropertiesItemDto
 */
export interface ResponseVehiclePropertiesItemDto {
  /**
   * Color of vehicle from registry
   * @type {string}
   * @memberof ResponseVehiclePropertiesItemDto
   */
  color?: string
  /**
   * Brand of vehicle from registry
   * @type {string}
   * @memberof ResponseVehiclePropertiesItemDto
   */
  brand?: string
  /**
   * Type of vehicle. Is it motorbike, or autobus or normal car or ... ?
   * @type {string}
   * @memberof ResponseVehiclePropertiesItemDto
   */
  vehicleType?: string
  /**
   * ID of vehicle from state registry
   * @type {number}
   * @memberof ResponseVehiclePropertiesItemDto
   */
  vehicleId: number
}
/**
 * Reason of scan
 * @export
 * @enum {string}
 */

export const ScanReasonEnum = {
  PaasParkingAuthorization: 'PAAS_PARKING_AUTHORIZATION',
  Research: 'RESEARCH',
  Testing: 'TESTING',
  Other: 'OTHER',
} as const

export type ScanReasonEnum = (typeof ScanReasonEnum)[keyof typeof ScanReasonEnum]

/**
 * Used to flag duplicity and PAAS parking violation. By default returns NO_VIOLATION / OTHER when PAAS_PARKING_AUTHORIZATION / OTHER scan reason set
 * @export
 * @enum {string}
 */

export const ScanResultEnum = {
  PaasParkingViolation: 'PAAS_PARKING_VIOLATION',
  PaasParkingViolationDuplicity: 'PAAS_PARKING_VIOLATION_DUPLICITY',
  Other: 'OTHER',
  NoViolation: 'NO_VIOLATION',
} as const

export type ScanResultEnum = (typeof ScanResultEnum)[keyof typeof ScanResultEnum]

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    defaultControllerHealthcheck: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async defaultControllerHealthcheck(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultResponseHealthcheck>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.defaultControllerHealthcheck(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.defaultControllerHealthcheck']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    defaultControllerHealthcheck(
      options?: AxiosRequestConfig,
    ): AxiosPromise<DefaultResponseHealthcheck> {
      return localVarFp
        .defaultControllerHealthcheck(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * See if nest is working!
   * @summary Healthcheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public defaultControllerHealthcheck(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .defaultControllerHealthcheck(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ScannersAndOffencesApi - axios parameter creator
 * @export
 */
export const ScannersAndOffencesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Upload photo to minio and save url with user to db
     * @summary Upload photo of zone sign.
     * @param {File} file Upload image
     * @param {string} [tag] Tag to image, e.g. zone number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerCreateFavouritePhoto: async (
      file: File,
      tag?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists('scanControllerCreateFavouritePhoto', 'file', file)
      const localVarPath = `/scan/favourite-photo/create`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (file !== undefined) {
        localVarFormParams.append('file', file as any)
      }

      if (tag !== undefined) {
        localVarFormParams.append('tag', tag as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Send id of scan, which founded offence. With this send all necessary data for create offence
     * @summary Create offence from last scanned ecv
     * @param {string} scanUuid
     * @param {RequestCreateOffenceDataDto} data
     * @param {Array<File>} files Send base64 of files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerCreateOffence: async (
      scanUuid: string,
      data: RequestCreateOffenceDataDto,
      files: Array<File>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'scanUuid' is not null or undefined
      assertParamExists('scanControllerCreateOffence', 'scanUuid', scanUuid)
      // verify required parameter 'data' is not null or undefined
      assertParamExists('scanControllerCreateOffence', 'data', data)
      // verify required parameter 'files' is not null or undefined
      assertParamExists('scanControllerCreateOffence', 'files', files)
      const localVarPath = `/scan/offence/create/{scanUuid}`.replace(
        `{${'scanUuid'}}`,
        encodeURIComponent(String(scanUuid)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (data !== undefined) {
        // TODO: fix
        localVarFormParams.append('data', JSON.stringify(data))
      }
      if (files) {
        files.forEach((element) => {
          localVarFormParams.append('files', element as any)
        })
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create scan of ecv if it is first time. Send if it is for checking parking authorizations, or it is just ordinary scan. It will return parking authorization if you need it. If there is repaired scan or manually repaired scan, sand also first scan ID.
     * @summary Create or update scan of ecv in database with some basic info about ECV
     * @param {RequestCreateOrUpdateScanDto} requestCreateOrUpdateScanDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerCreateOrUpdateScanEcv: async (
      requestCreateOrUpdateScanDto: RequestCreateOrUpdateScanDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestCreateOrUpdateScanDto' is not null or undefined
      assertParamExists(
        'scanControllerCreateOrUpdateScanEcv',
        'requestCreateOrUpdateScanDto',
        requestCreateOrUpdateScanDto,
      )
      const localVarPath = `/scan/create-or-update`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestCreateOrUpdateScanDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Search for offences by ecv, gps coordinates and optionally offence type
     * @summary Find offences
     * @param {string} ecv Vehicle ecv
     * @param {Array<ScanControllerGetDuplicitOffenceOffenceTypesEnum>} [offenceTypes] Find offences filtered by offence type
     * @param {string} [udr] Udr code
     * @param {string} [lat] Used to check for duplicities at the same place
     * @param {string} [_long] Used to check for duplicities at the same place
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerGetDuplicitOffence: async (
      ecv: string,
      offenceTypes?: Array<ScanControllerGetDuplicitOffenceOffenceTypesEnum>,
      udr?: string,
      lat?: string,
      _long?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ecv' is not null or undefined
      assertParamExists('scanControllerGetDuplicitOffence', 'ecv', ecv)
      const localVarPath = `/scan/offences`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (offenceTypes) {
        localVarQueryParameter['offenceTypes'] = offenceTypes
      }

      if (ecv !== undefined) {
        localVarQueryParameter['ecv'] = ecv
      }

      if (udr !== undefined) {
        localVarQueryParameter['udr'] = udr
      }

      if (lat !== undefined) {
        localVarQueryParameter['lat'] = lat
      }

      if (_long !== undefined) {
        localVarQueryParameter['long'] = _long
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Return photos made today by authenticated user
     * @summary Get favourite photos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerGetFavouritePhotos: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/scan/favourite-photo/photos`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It can return more than one vehicle for one licence plate. Than user can decide, which vehicle is the right.
     * @summary Return basic properties of vehicle from state registry.
     * @param {string} ecv
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerGetVehicleProperties: async (
      ecv: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ecv' is not null or undefined
      assertParamExists('scanControllerGetVehicleProperties', 'ecv', ecv)
      const localVarPath = `/scan/vehicle-properties/{ecv}`.replace(
        `{${'ecv'}}`,
        encodeURIComponent(String(ecv)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ScannersAndOffencesApi - functional programming interface
 * @export
 */
export const ScannersAndOffencesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ScannersAndOffencesApiAxiosParamCreator(configuration)
  return {
    /**
     * Upload photo to minio and save url with user to db
     * @summary Upload photo of zone sign.
     * @param {File} file Upload image
     * @param {string} [tag] Tag to image, e.g. zone number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scanControllerCreateFavouritePhoto(
      file: File,
      tag?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetFavouritePhotoDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scanControllerCreateFavouritePhoto(
        file,
        tag,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScannersAndOffencesApi.scanControllerCreateFavouritePhoto']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Send id of scan, which founded offence. With this send all necessary data for create offence
     * @summary Create offence from last scanned ecv
     * @param {string} scanUuid
     * @param {RequestCreateOffenceDataDto} data
     * @param {Array<File>} files Send base64 of files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scanControllerCreateOffence(
      scanUuid: string,
      data: RequestCreateOffenceDataDto,
      files: Array<File>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreateOffenceDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scanControllerCreateOffence(
        scanUuid,
        data,
        files,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScannersAndOffencesApi.scanControllerCreateOffence']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Create scan of ecv if it is first time. Send if it is for checking parking authorizations, or it is just ordinary scan. It will return parking authorization if you need it. If there is repaired scan or manually repaired scan, sand also first scan ID.
     * @summary Create or update scan of ecv in database with some basic info about ECV
     * @param {RequestCreateOrUpdateScanDto} requestCreateOrUpdateScanDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scanControllerCreateOrUpdateScanEcv(
      requestCreateOrUpdateScanDto: RequestCreateOrUpdateScanDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreateOrUpdateScanDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scanControllerCreateOrUpdateScanEcv(
        requestCreateOrUpdateScanDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScannersAndOffencesApi.scanControllerCreateOrUpdateScanEcv']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Search for offences by ecv, gps coordinates and optionally offence type
     * @summary Find offences
     * @param {string} ecv Vehicle ecv
     * @param {Array<ScanControllerGetDuplicitOffenceOffenceTypesEnum>} [offenceTypes] Find offences filtered by offence type
     * @param {string} [udr] Udr code
     * @param {string} [lat] Used to check for duplicities at the same place
     * @param {string} [_long] Used to check for duplicities at the same place
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scanControllerGetDuplicitOffence(
      ecv: string,
      offenceTypes?: Array<ScanControllerGetDuplicitOffenceOffenceTypesEnum>,
      udr?: string,
      lat?: string,
      _long?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseCreateOffenceDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scanControllerGetDuplicitOffence(
        ecv,
        offenceTypes,
        udr,
        lat,
        _long,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScannersAndOffencesApi.scanControllerGetDuplicitOffence']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Return photos made today by authenticated user
     * @summary Get favourite photos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scanControllerGetFavouritePhotos(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetFavouritePhotosDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.scanControllerGetFavouritePhotos(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScannersAndOffencesApi.scanControllerGetFavouritePhotos']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * It can return more than one vehicle for one licence plate. Than user can decide, which vehicle is the right.
     * @summary Return basic properties of vehicle from state registry.
     * @param {string} ecv
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scanControllerGetVehicleProperties(
      ecv: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseVehiclePropertiesDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scanControllerGetVehicleProperties(
        ecv,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScannersAndOffencesApi.scanControllerGetVehicleProperties']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ScannersAndOffencesApi - factory interface
 * @export
 */
export const ScannersAndOffencesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ScannersAndOffencesApiFp(configuration)
  return {
    /**
     * Upload photo to minio and save url with user to db
     * @summary Upload photo of zone sign.
     * @param {File} file Upload image
     * @param {string} [tag] Tag to image, e.g. zone number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerCreateFavouritePhoto(
      file: File,
      tag?: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<ResponseGetFavouritePhotoDto> {
      return localVarFp
        .scanControllerCreateFavouritePhoto(file, tag, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Send id of scan, which founded offence. With this send all necessary data for create offence
     * @summary Create offence from last scanned ecv
     * @param {string} scanUuid
     * @param {RequestCreateOffenceDataDto} data
     * @param {Array<File>} files Send base64 of files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerCreateOffence(
      scanUuid: string,
      data: RequestCreateOffenceDataDto,
      files: Array<File>,
      options?: AxiosRequestConfig,
    ): AxiosPromise<ResponseCreateOffenceDto> {
      return localVarFp
        .scanControllerCreateOffence(scanUuid, data, files, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Create scan of ecv if it is first time. Send if it is for checking parking authorizations, or it is just ordinary scan. It will return parking authorization if you need it. If there is repaired scan or manually repaired scan, sand also first scan ID.
     * @summary Create or update scan of ecv in database with some basic info about ECV
     * @param {RequestCreateOrUpdateScanDto} requestCreateOrUpdateScanDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerCreateOrUpdateScanEcv(
      requestCreateOrUpdateScanDto: RequestCreateOrUpdateScanDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<ResponseCreateOrUpdateScanDto> {
      return localVarFp
        .scanControllerCreateOrUpdateScanEcv(requestCreateOrUpdateScanDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Search for offences by ecv, gps coordinates and optionally offence type
     * @summary Find offences
     * @param {string} ecv Vehicle ecv
     * @param {Array<ScanControllerGetDuplicitOffenceOffenceTypesEnum>} [offenceTypes] Find offences filtered by offence type
     * @param {string} [udr] Udr code
     * @param {string} [lat] Used to check for duplicities at the same place
     * @param {string} [_long] Used to check for duplicities at the same place
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerGetDuplicitOffence(
      ecv: string,
      offenceTypes?: Array<ScanControllerGetDuplicitOffenceOffenceTypesEnum>,
      udr?: string,
      lat?: string,
      _long?: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Array<ResponseCreateOffenceDto>> {
      return localVarFp
        .scanControllerGetDuplicitOffence(ecv, offenceTypes, udr, lat, _long, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Return photos made today by authenticated user
     * @summary Get favourite photos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerGetFavouritePhotos(
      options?: AxiosRequestConfig,
    ): AxiosPromise<ResponseGetFavouritePhotosDto> {
      return localVarFp
        .scanControllerGetFavouritePhotos(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * It can return more than one vehicle for one licence plate. Than user can decide, which vehicle is the right.
     * @summary Return basic properties of vehicle from state registry.
     * @param {string} ecv
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scanControllerGetVehicleProperties(
      ecv: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<ResponseVehiclePropertiesDto> {
      return localVarFp
        .scanControllerGetVehicleProperties(ecv, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ScannersAndOffencesApi - object-oriented interface
 * @export
 * @class ScannersAndOffencesApi
 * @extends {BaseAPI}
 */
export class ScannersAndOffencesApi extends BaseAPI {
  /**
   * Upload photo to minio and save url with user to db
   * @summary Upload photo of zone sign.
   * @param {File} file Upload image
   * @param {string} [tag] Tag to image, e.g. zone number
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScannersAndOffencesApi
   */
  public scanControllerCreateFavouritePhoto(
    file: File,
    tag?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ScannersAndOffencesApiFp(this.configuration)
      .scanControllerCreateFavouritePhoto(file, tag, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Send id of scan, which founded offence. With this send all necessary data for create offence
   * @summary Create offence from last scanned ecv
   * @param {string} scanUuid
   * @param {RequestCreateOffenceDataDto} data
   * @param {Array<File>} files Send base64 of files
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScannersAndOffencesApi
   */
  public scanControllerCreateOffence(
    scanUuid: string,
    data: RequestCreateOffenceDataDto,
    files: Array<File>,
    options?: RawAxiosRequestConfig,
  ) {
    return ScannersAndOffencesApiFp(this.configuration)
      .scanControllerCreateOffence(scanUuid, data, files, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create scan of ecv if it is first time. Send if it is for checking parking authorizations, or it is just ordinary scan. It will return parking authorization if you need it. If there is repaired scan or manually repaired scan, sand also first scan ID.
   * @summary Create or update scan of ecv in database with some basic info about ECV
   * @param {RequestCreateOrUpdateScanDto} requestCreateOrUpdateScanDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScannersAndOffencesApi
   */
  public scanControllerCreateOrUpdateScanEcv(
    requestCreateOrUpdateScanDto: RequestCreateOrUpdateScanDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ScannersAndOffencesApiFp(this.configuration)
      .scanControllerCreateOrUpdateScanEcv(requestCreateOrUpdateScanDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Search for offences by ecv, gps coordinates and optionally offence type
   * @summary Find offences
   * @param {string} ecv Vehicle ecv
   * @param {Array<ScanControllerGetDuplicitOffenceOffenceTypesEnum>} [offenceTypes] Find offences filtered by offence type
   * @param {string} [udr] Udr code
   * @param {string} [lat] Used to check for duplicities at the same place
   * @param {string} [_long] Used to check for duplicities at the same place
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScannersAndOffencesApi
   */
  public scanControllerGetDuplicitOffence(
    ecv: string,
    offenceTypes?: Array<ScanControllerGetDuplicitOffenceOffenceTypesEnum>,
    udr?: string,
    lat?: string,
    _long?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ScannersAndOffencesApiFp(this.configuration)
      .scanControllerGetDuplicitOffence(ecv, offenceTypes, udr, lat, _long, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Return photos made today by authenticated user
   * @summary Get favourite photos
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScannersAndOffencesApi
   */
  public scanControllerGetFavouritePhotos(options?: RawAxiosRequestConfig) {
    return ScannersAndOffencesApiFp(this.configuration)
      .scanControllerGetFavouritePhotos(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * It can return more than one vehicle for one licence plate. Than user can decide, which vehicle is the right.
   * @summary Return basic properties of vehicle from state registry.
   * @param {string} ecv
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScannersAndOffencesApi
   */
  public scanControllerGetVehicleProperties(ecv: string, options?: RawAxiosRequestConfig) {
    return ScannersAndOffencesApiFp(this.configuration)
      .scanControllerGetVehicleProperties(ecv, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const ScanControllerGetDuplicitOffenceOffenceTypesEnum = {
  A: 'A',
  B: 'B',
  C: 'C',
  D: 'D',
  E: 'E',
  F: 'F',
  G: 'G',
  H: 'H',
  I: 'I',
  J: 'J',
  K: 'K',
  L: 'L',
  M: 'M',
  N: 'N',
  O: 'O',
  P: 'P',
  Q: 'Q',
  R: 'R',
  S: 'S',
  T: 'T',
  U: 'U',
  Dz: 'DZ',
  NB: 'N_B',
} as const
export type ScanControllerGetDuplicitOffenceOffenceTypesEnum =
  (typeof ScanControllerGetDuplicitOffenceOffenceTypesEnum)[keyof typeof ScanControllerGetDuplicitOffenceOffenceTypesEnum]

/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get latest mobile app version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerGetMobileAppVersion: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/system/version`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update mobile app version
     * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerUpdateMobileAppVersion: async (
      mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'mobileAppVersionUpdateDto' is not null or undefined
      assertParamExists(
        'systemControllerUpdateMobileAppVersion',
        'mobileAppVersionUpdateDto',
        mobileAppVersionUpdateDto,
      )
      const localVarPath = `/system/version`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        mobileAppVersionUpdateDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get latest mobile app version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async systemControllerGetMobileAppVersion(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.systemControllerGetMobileAppVersion(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['SystemApi.systemControllerGetMobileAppVersion']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Update mobile app version
     * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async systemControllerUpdateMobileAppVersion(
      mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.systemControllerUpdateMobileAppVersion(
          mobileAppVersionUpdateDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['SystemApi.systemControllerUpdateMobileAppVersion']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SystemApiFp(configuration)
  return {
    /**
     *
     * @summary Get latest mobile app version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerGetMobileAppVersion(options?: AxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .systemControllerGetMobileAppVersion(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update mobile app version
     * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemControllerUpdateMobileAppVersion(
      mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .systemControllerUpdateMobileAppVersion(mobileAppVersionUpdateDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
  /**
   *
   * @summary Get latest mobile app version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public systemControllerGetMobileAppVersion(options?: RawAxiosRequestConfig) {
    return SystemApiFp(this.configuration)
      .systemControllerGetMobileAppVersion(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update mobile app version
   * @param {MobileAppVersionUpdateDto} mobileAppVersionUpdateDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public systemControllerUpdateMobileAppVersion(
    mobileAppVersionUpdateDto: MobileAppVersionUpdateDto,
    options?: RawAxiosRequestConfig,
  ) {
    return SystemApiFp(this.configuration)
      .systemControllerUpdateMobileAppVersion(mobileAppVersionUpdateDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
